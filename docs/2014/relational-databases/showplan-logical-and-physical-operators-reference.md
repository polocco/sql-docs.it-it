---
title: Guida di riferimento a operatori Showplan logici e fisici | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: 57f1d15c67113bbadd40861b886d6929aacd3467
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/18/2020
ms.locfileid: "85016969"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Guida di riferimento a operatori Showplan logici e fisici
  Gli operatori descrivono la modalità di esecuzione di una query o di un'istruzione del linguaggio di manipolazione dei dati (DML, Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] . In Query Optimizer gli operatori consentono di compilare un piano di query per ottenere i risultati specificati nella query o per eseguire l'operazione specificata nell'istruzione DML. Il piano di query è un albero composto da operatori fisici che è possibile visualizzare tramite le istruzioni SET SHOWPLAN, le opzioni del piano di esecuzione grafico in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]o le classi di eventi Showplan di SQL Server Profiler.  
  
 Gli operatori sono suddivisi in operatori logici e fisici.  
  
 **Operatori logici**  
 Gli operatori logici descrivono l'operazione algebrica relazionale utilizzata per elaborare un'istruzione, ovvero descrivono a livello concettuale quale operazione deve essere eseguita.  
  
 **Operatori fisici**  
 Gli operatori fisici implementano l'operazione descritta dagli operatori logici. Ogni operatore fisico è un oggetto o una routine che esegue un'operazione. Alcuni operatori fisici, ad esempio, accedono alle colonne o alle righe di una tabella, di un indice o di una vista, mentre altri eseguono operazioni diverse, ad esempio calcoli, aggregazioni, controlli di integrità dei dati o creazione di join. Gli operatori fisici possono influire sulle prestazioni.  
  
 Dopo essere stati inizializzati, gli operatori fisici raccolgono dati e quindi vengono chiusi. Un operatore fisico risponde alle tre chiamate di metodo seguenti:  
  
-   **Init()** : con la chiamata del metodo **Init()** un operatore fisico si autoinizializza e imposta le strutture di dati necessarie. Sebbene l'operatore fisico possa ricevere molte chiamate **Init()** , in genere ne riceve una sola.  
  
-   **GetNext()** : con la chiamata del metodo **GetNext()** un operatore fisico recupera la prima riga di dati oppure la successiva. L'operatore fisico può ricevere più chiamate **GetNext()** oppure nessuna.  
  
-   **Close()** : con la chiamata del metodo **Close()** un operatore fisico esegue alcune operazioni di eliminazione e viene quindi chiuso automaticamente. Un operatore fisico riceve una sola chiamata del metodo **Close()** .  
  
 Il metodo **GetNext()** restituisce una riga di dati e il numero di chiamate ricevute viene visualizzato come **ActualRows** nell'output Showplan generato usando SET STATISTICS PROFILE ON o SET STATISTICS XML ON. Per altre informazioni su queste opzioni SET, vedere [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) e [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 I conteggi **ActualRebinds** e **ActualRewinds** visualizzati nell'output Showplan fanno riferimento al numero di chiamate al metodo **Init()** . A meno che un operatore non sia nel lato interno di un join ciclico, **ActualRebinds** è uguale a uno e **ActualRewinds** è uguale a zero. Se un operatore si trova nel lato interno di un join ciclico, la somma del numero delle associazioni e dei ripristini dovrebbe essere pari al numero delle righe elaborate nel lato esterno del join. Una riassociazione significa che uno o più parametri correlati del join sono stati modificati e che è necessario rivalutare il lato interno. Un ripristino significa che nessuno dei parametri correlati è stato modificato e che è possibile riutilizzare il set di risultati interno precedente.  
  
 **ActualRebinds** e **ActualRewinds** sono inclusi nell'output Showplan XML generato utilizzando SET STATISTICS XML ON. Vengono popolate solo per gli operatori **Index Spool**, `Remote Query` , **Row Count**,, `Sort` **Table Spool**e **Table-valued Function** . **ActualRebinds** e **ActualRewinds** possono essere popolati anche per gli `Assert` operatori di **filtro** e quando l'attributo **StartupExpression** è impostato su true.  
  
 Quando **ActualRebinds** e **ActualRewinds** sono inclusi in uno Showplan XML, sono confrontabili con **EstimateRebinds** e **EstimateRewinds**. Quando non sono presenti, il numero di righe stimato (**EstimateRows**) è confrontabile con il numero effettivo di righe (**ActualRows**). Si noti che nell'output grafico effettivo Showplan viene visualizzato zero per le riassociazioni e i ripristini effettivi quando non presenti.  
  
 Un contatore correlato, **ActualEndOfScans**, è disponibile solo quando l'output Showplan viene generato utilizzando SET STATISTICS XML ON. Ogni volta che un operatore fisico raggiunge la fine del proprio flusso di dati, il contatore viene incrementato di uno. Un operatore fisico può raggiungere la fine del proprio flusso di dati, zero, una o più volte. Come per riassociazioni e ripristini, il numero di analisi terminate può essere maggiore di uno se l'operatore si trova nel lato interno di un join ciclico. Il numero di analisi terminate dovrebbe essere minore o uguale alla somma del numero di riassociazioni e ripristini.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mapping di operatori logici e fisici  
 In Query Optimizer viene creato un piano di query che consiste in un albero di operatori logici. Dopo la creazione del piano, viene scelto l'operatore fisico più efficiente per ogni operatore logico. L'operatore fisico che implementerà un operatore logico viene individuato in base al costo.  
  
 In genere un'operazione logica può essere implementata da più operatori fisici. In alcuni casi rari tuttavia anche un operatore fisico può implementare più operazioni logiche.  
  
## <a name="operator-descriptions"></a>Descrizioni dell'operatore  
 In questa sezione vengono descritti gli operatori fisici e logici.  
  
|Icona del piano di esecuzione grafico|Operatore Showplan|Descrizione|  
|-----------------------------------|-----------------------|-----------------|  
|nessuno|`Aggregate`|L'operatore `Aggregate` calcola il valore di un'espressione che include MIN, MAX, SUM, COUNT o AVG. `Aggregate` può essere un operatore logico o fisico.|  
|![Icona dell'operatore Arithmetic Expression](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Icona dell'operatore Arithmetic Expression")|`Arithmetic Expression`|L'operatore `Arithmetic Expression` calcola un nuovo valore da valori esistenti in una riga. `Arithmetic Expression` non viene utilizzato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icona dell'operatore Assert](../../2014/database-engine/media/assert-32x.gif "Icona dell'operatore Assert")|`Assert`|L'operatore `Assert` verifica una condizione, ad esempio convalida l'integrità referenziale oppure verifica che una sottoquery scalare restituisca una riga. Per ogni riga di input, l' `Assert` operatore valuta l'espressione nella `Argument` colonna del piano di esecuzione. Se questa espressione restituisce NULL, la riga viene passata tramite l'operatore `Assert` e l'esecuzione della query procede. Se l'operazione restituisce un valore non NULL, verrà generato l'errore appropriato. `Assert` è un operatore fisico.|  
|![Icona dell'elemento di linguaggio Assign](../../2014/database-engine/media/assign-32.gif "Icona dell'elemento di linguaggio Assign")|`Assign`|L'operatore `Assign` assegna il valore di un'espressione o di una costante a una variabile. `Assign` è un elemento di linguaggio.|  
|nessuno|`Asnyc Concat`|L'operatore `Asnyc Concat` viene utilizzato solo nelle query remote (query distribuite) È caratterizzato da *n* nodi figlio e un nodo padre. Alcuni nodi figlio sono normalmente computer remoti che partecipano a una query distribuita. `Asnyc Concat` invia chiamate `open()` simultanee a tutti i figli e quindi applica una mappa di bit a ogni figlio. Per ogni bit che corrisponde a 1, `Async Concat` invia le righe di output al nodo padre su richiesta.|  
|![Icona dell'operatore Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icona dell'operatore Bitmap")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]Usa l' `Bitmap` operatore per implementare l'applicazione di filtri bitmap nei piani di query paralleli. Il filtro bitmap velocizza l'esecuzione delle query eliminando le righe con valori di chiave che non possono produrre record di join prima di passare le righe tramite un altro operatore, ad esempio l' `Parallelism` operatore. Un filtro bitmap utilizza una rappresentazione compatta di un set di valori da una tabella in una parte dell'albero dell'operatore per filtrare le righe da una seconda tabella in un'altra parte dell'albero. Rimuovendo le righe non necessarie quanto prima nella query, gli operatori successivi hanno meno righe su cui lavorare e le prestazioni complessive della query migliorano. Query Optimizer determina quando un bitmap è sufficientemente selettivo per essere utile e a quali operatori il filtro viene applicato. `Bitmap` è un operatore fisico.|  
|![Icona dell'operatore Bitmap](../../2014/database-engine/media/bitmap-32x.gif "Icona dell'operatore Bitmap")|`Bitmap Create`|L'operatore `Bitmap Create` è visualizzato nell'output Showplan in cui vengono compilate le mappe di bit. `Bitmap Create` è un operatore logico.|  
|![Icona dell'operatore Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icona dell'operatore Bookmark Lookup")|`Bookmark Lookup`|L'operatore `Bookmark Lookup` utilizza un segnalibro (ID di riga o chiave di clustering) per cercare la riga corrispondente nella tabella o nell'indice cluster. La `Argument` colonna contiene l'etichetta del segnalibro utilizzata per la ricerca della riga nella tabella o nell'indice cluster. La `Argument` colonna contiene inoltre il nome della tabella o dell'indice cluster in cui viene cercata la riga. Se la clausola WITH PREFETCH viene visualizzata nella `Argument` colonna, query processor ha determinato che è ottimale utilizzare la prelettura asincrona (Read-Ahead) per la ricerca di segnalibri nella tabella o nell'indice cluster.<br /><br /> `Bookmark Lookup` non viene utilizzato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. `Clustered Index Seek` e `RID Lookup` consentono invece di eseguire la ricerca tramite segnalibro. Tale funzionalità è supportata inoltre dall'operatore `Key Lookup`.|  
|nessuno|`Branch Repartition`|In un piano di query parallele sono presenti talvolta regioni concettuali di iteratori. È possibile eseguire tutti gli iteratori all'interno di tale regione mediante thread paralleli. Le regioni devono invece essere eseguite in modalità seriale. Alcuni iteratori `Parallelism` all'interno di una singola regione sono denominati `Branch Repartition`. L'operatore `Parallelism` al confine tra due regioni di questo tipo viene denominato `Segment Repartition`. `Branch Repartition` e `Segment Repartition` sono operatori logici.|  
|nessuno|`Broadcast`|`Broadcast`ha un nodo figlio e *n* nodi padre. `Broadcast` invia le proprie righe di input a più consumer su richiesta. Ogni consumer riceve tutte le righe. Ad esempio, se tutti i consumer rappresentano i lati di un hash join, verranno compilate *n* copie delle tabelle hash.|  
|![Icona dell'operatore Build Hash](../../2014/database-engine/media/build-hash.gif "Icona dell'operatore Build Hash")|`Build Hash`|Indica la compilazione di una tabella hash in batch per un indice columnstore con ottimizzazione per la memoria xVelocity.|  
|nessuno|`Cache`|`Cache`è una versione specializzata dell'operatore **spool** . che consente di archiviare solo una riga di dati. `Cache` è un operatore logico. `Cache` non viene utilizzato in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icona dell'operatore Clustered Index Delete](../../2014/database-engine/media/clustered-index-delete-32x.gif "Icona dell'operatore Clustered Index Delete")|`Clustered Index Delete`|L'operatore `Clustered Index Delete` elimina righe dall'indice cluster specificato nella colonna dell'argomento del piano di esecuzione della query. Se nella colonna dell'argomento è presente un predicato WHERE(), vengono eliminate solo le righe conformi al predicato.`Clustered Index Delete`  è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Insert](../../2014/database-engine/media/clustered-index-insert-32x.gif "Icona dell'operatore Clustered Index Insert")|`Clustered Index Insert`|L'operatore Showplan `Clustered Index Insert` consente di inserire le righe dell'input generato nell'indice cluster specificato nella colonna Argument. La colonna Argument include inoltre il predicato SET:(), il quale indica il valore su cui è impostata ogni colonna. Se `Clustered Index Insert` non ha figli per i valori Insert, la riga inserita viene ricavata dall' `Insert` operatore stesso.`Clustered Index Insert`  è un operatore fisico.|  
|![Operatore Clustered Index Merge](../../2014/database-engine/media/clustered-index-merge-32x.gif "Operatore Clustered Index Merge")|**Clustered Index Merge**|L'operatore **Clustered Index Merge** applica un flusso di dati di unione a un indice cluster. L'operatore Elimina, aggiorna o inserisce righe dall'indice cluster specificato nella `Argument` colonna dell'operatore. L'operazione effettiva eseguita dipende dal valore di runtime della colonna **Action** specificata nella `Argument` colonna dell'operatore. **Clustered Index Merge** è un operatore fisico.|  
|![Icona dell'operatore Clustered Index Scan](../../2014/database-engine/media/clustered-index-scan-32x.gif "Icona dell'operatore Clustered Index Scan")|`Clustered Index Scan`|L'operatore `Clustered Index Scan` esegue l'analisi dell'indice cluster specificato nella colonna Argument del piano di esecuzione della query. In presenza di un predicato facoltativo WHERE:(), vengono restituite solo le righe conformi al predicato. Se la colonna Argomento include la clausola ORDERED, Query Processor ha richiesto la restituzione dell'output delle righe nell'ordine utilizzato dall'indice cluster. Se la clausola ORDERED non è presente, il motore di archiviazione esegue l'analisi dell'indice in modo ottimale, senza necessariamente ordinare l'output. `Clustered Index Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Clustered Index Seek](../../2014/database-engine/media/clustered-index-seek-32x.gif "Icona dell'operatore Clustered Index Seek")|`Clustered Index Seek`|L'operatore `Clustered Index Seek` utilizza le funzionalità di ricerca degli indici per recuperare righe da un indice cluster. La `Argument` colonna contiene il nome dell'indice cluster utilizzato e il predicato SEEK:(). Il motore di archiviazione utilizza l'indice per elaborare soltanto le righe conformi al predicato SEEK:(). Può inoltre includere un predicato WHERE:() in cui il motore di archiviazione valuta tutte le righe che sono conformi al predicato SEEK:(). Si tratta però di un predicato facoltativo, che non utilizza gli indici per completare l'elaborazione.<br /><br /> Se la `Argument` colonna contiene la clausola ORDERED, query processor ha determinato che le righe devono essere restituite nell'ordine in cui sono state ordinate dall'indice cluster. Se la clausola ORDERED non è presente, il motore di archiviazione esegue la ricerca nell'indice in modo ottimale, senza necessariamente ordinare l'output. Il mantenimento dell'ordinamento dell'output può dare come risultato un livello di efficienza minore rispetto alla restituzione di output non ordinato. Quando viene visualizzata la parola chiave LOOKUP, è in esecuzione una ricerca tramite segnalibro. In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] e versioni successive l' `Key Lookup` operatore fornisce funzionalità di ricerca dei segnalibri. `Clustered Index Seek` è un operatore logico e fisico.|  
|![Icona dell'operatore Clustered Index Update](../../2014/database-engine/media/clustered-index-update-32x.gif "Icona dell'operatore Clustered Index Update")|`Clustered Index Update`|L' `Clustered Index Update` operatore aggiorna le righe di input nell'indice cluster specificato nella `Argument` colonna. Se è presente un predicato WHERE:(), vengono aggiornate solo le righe che soddisfano il predicato. Se è stato specificato un predicato SET:(), ogni colonna aggiornata viene impostata su tale valore. Se è disponibile un predicato DEFINE:(), vengono elencati i valori definiti da tale operatore. Un riferimento a tali valori può essere presente nella clausola SET o altrove nell'operatore o nella query. `Clustered Index Update` è un operatore logico e fisico.|  
|![Icona dell'operatore Collapse](../../2014/database-engine/media/collapse-32x.gif "Icona dell'operatore Collapse")|`Collapse`|L'operatore `Collapse` ottimizza l'elaborazione degli aggiornamenti. Quando si esegue un aggiornamento, è possibile suddividerlo in un'operazione di eliminazione e un'operazione di inserimento tramite l'operatore `Split`. La `Argument` colonna contiene una clausola Group by:() che specifica un elenco di colonne chiave. Se in Query Processor vengono rilevate righe adiacenti che eliminano e inseriscono gli stessi valori chiave, queste operazioni separate vengono sostituite con una singola operazione di aggiornamento più efficiente. `Collapse` è un operatore logico e fisico.|  
|![Analisi indice columnstore](../../2014/database-engine/media/columnstoreindexscan.gif "Analisi indice Columnstore")|`Columnstore Index Scan`|L' `Columnstore Index Scan` operatore esegue l'analisi dell'indice columnstore specificato nella `Argument` colonna del piano di esecuzione della query.|  
|![Icona dell'operatore Compute Scalar](../../2014/database-engine/media/compute-scalar-32x.gif "Icona dell'operatore Compute Scalar")|`Compute Scalar`|L' `Compute Scalar` operatore valuta un'espressione per produrre un valore scalare calcolato. Tale valore può essere restituito all'utente e/o utilizzato come riferimento in altre parti della query, ad esempio in un predicato di filtro o di join. `Compute Scalar` è un operatore logico e fisico.<br /><br /> `Compute Scalar`gli operatori visualizzati negli Showplan generati da SET STATISTICs XML potrebbero non contenere l' `RunTimeInformation` elemento. Negli Showplan grafici è possibile che **Actual Rows**, **Actual Rebinds**e **Actual Rewinds** non siano presenti nella finestra **Proprietà** quando l'opzione **Includi piano di esecuzione effettivo** è selezionata in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Questo indica che, sebbene questi operatori fossero utilizzati nel piano di query compilato, la loro funzione è stata svolta da altri operatori nel piano di query di run-time. Si noti inoltre che il numero di esecuzioni nell'output di Showplan generato da SET STATISTICS PROFILE equivale alla somma di riassociazioni e ripristini in Showplan generati da SET STATISTICS XML.|  
|![Icona dell'operatore Concatenation](../../2014/database-engine/media/concatenation-32x.gif "Icona dell'operatore Concatenation")|**Concatenazione**|L'operatore **Concatenation** esegue l'analisi di più input e restituisce ogni riga sottoposta ad analisi. L'operatore**Concatenation** in genere viene utilizzato per implementare il costrutto [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. L'operatore fisico **Concatenation** prevede uno o più input e un output e copia le righe dal primo flusso di input nel flusso di output, quindi ripete l'operazione per ogni flusso di input aggiuntivo. **Concatenation** è un operatore logico e fisico.|  
|![Icona dell'operatore Constant Scan](../../2014/database-engine/media/constant-scan-32x.gif "Icona dell'operatore Constant Scan")|`Constant Scan`|L' `Constant Scan` operatore introduce una o più righe costanti in una query. Un `Compute Scalar` operatore viene spesso usato dopo un oggetto `Constant Scan` per aggiungere colonne a una riga prodotta dall' `Constant Scan` operatore.|  
|![Icona dell'elemento di linguaggio Convert (motore di database)](../../2014/database-engine/media/convert-32x.gif "Icona dell'elemento di linguaggio Convert (motore di database)")|`Convert`|L'operatore `Convert` converte un tipo di dati scalare in un altro. `Convert` è un elemento di linguaggio.|  
|nessuno|`Cross Join`|L'operatore `Cross Join` crea un join tra ogni riga del primo input (superiore) e ogni riga del secondo input (inferiore). `Cross Join` è un operatore logico.|  
|![Icona dell'operatore Cursor Catchall](../../2014/database-engine/media/cursor-catch-all.gif "Icona dell'operatore Cursor Catchall")|`catchall`|L'icona generica viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per gli elementi del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|nessuno|**Cursore**|Gli operatori logici e fisici **Cursor** consentono di descrivere le modalità di esecuzione di una query o di un aggiornamento che implicano operazioni con i cursori. Gli operatori fisici descrivono l'algoritmo di implementazione fisica utilizzato per l'elaborazione del cursore, ad esempio l'utilizzo di un cursore gestito da keyset. Ogni passaggio dell'esecuzione di un cursore implica un operatore fisico. Gli operatori logici descrivono una proprietà del cursore, ad esempio la proprietà di sola lettura.<br /><br /> Gli operatori logici includono Asynchronous, Optimistic, Primary, Read Only, Scroll Locks e Secondary and Synchronous,<br /><br /> mentre quelli fisici includono Dynamic, Fetch Query, Keyset, Population Query, Refresh Query e Snapshot.|  
|![Icona dell'elemento di linguaggio Declare](../../2014/database-engine/media/declare-32x.gif "Icona dell'elemento di linguaggio Declare")|`Declare`|L' `Declare` operatore alloca una variabile locale nel piano di query. `Declare` è un elemento di linguaggio.|  
|![Icona dell'operatore Delete (motore di database)](../../2014/database-engine/media/delete-32x.gif "Icona dell'operatore Delete (motore di database)")|`Delete`|L' `Delete` operatore Elimina da un oggetto righe che soddisfano il predicato facoltativo nella `Argument` colonna.|  
|![Icona dell'operatore Delete Scan](../../2014/database-engine/media/delete-scan-32x.gif "Icona dell'operatore Delete Scan")|`Deleted Scan`|L'operatore `Deleted Scan` esegue l'analisi della tabella eliminata all'interno di un trigger.|  
|nessuno|`Distinct`|L'operatore `Distinct` rimuove i duplicati da un set di righe o da una raccolta di valori. `Distinct` è un operatore logico.|  
|nessuno|`Distinct Sort`|L' `Distinct Sort` operatore logico esegue l'analisi dell'input, rimuovendo i duplicati e ordinando le colonne specificate nel predicato DISTINCT ORDER BY:() della `Argument` colonna. `Distinct Sort` è un operatore logico.|  
|![Icona dell'operatore Distribute Streams Parallelism](../../2014/database-engine/media/parallelism-distribute-stream.gif "Icona dell'operatore Distribute Streams Parallelism")|**Distribute Streams**|L'operatore **Distribute Streams** viene utilizzato esclusivamente in piani di query parallele. L'operatore **Distribute Streams** elabora un singolo flusso di input di record e produce più flussi di output. Il contenuto e il formato del record non vengono modificati. Ogni record del flusso di input appare in uno dei flussi di output. L'operatore mantiene automaticamente l'ordine relativo dei record di input nei flussi di output. In genere, l'appartenenza di un record di input a un flusso di output viene determinata tramite un'operazione di hashing.<br /><br /> Se l'output è partizionato, la `Argument` colonna contiene un predicato:() delle colonne di partizione e le colonne di partizionamento. **Distribute Streams** è un operatore logico.|  
|![Icona dell'operatore Dynamic Cursor](../../2014/database-engine/media/dynamic-32x.gif "Icona dell'operatore Dynamic Cursor")|`Dynamic`|L'operatore `Dynamic` utilizza un cursore che può visualizzare tutte le modifiche apportate da altri utenti.|  
|![Icona dell'operatore Spool](../../2014/database-engine/media/spool-32x.gif "Icona dell'operatore Spool")|**Eager Spool**|L'operatore **Eager Spool** accetta l'intero input e archivia ogni riga in un oggetto temporaneo nascosto archiviato nel `tempdb` database. Se l'operatore viene riavvolto (ad esempio, da un `Nested Loops` operatore) ma non è necessaria alcuna riassociazione, i dati di spooling vengono utilizzati al posto della ripetizione dell'analisi dell'input. Se è necessario ripetere l'associazione, i dati di spooling vengono eliminati e l'oggetto di spooling viene ricompilato tramite una nuova analisi dell'input riassociato. L'operatore **Eager Spool** compila il proprio file di spooling nel modo seguente. Quando l'operatore principale dello spooling richiede la prima riga, l'operatore di spooling utilizza tutte le righe dal proprio operatore di input e le archivia nello spooling. **Eager Spool** è un operatore logico.|  
|![Icona dell'operatore Fetch Query Cursor](../../2014/database-engine/media/fetch-query-32x.gif "Icona dell'operatore Fetch Query Cursor")|`Fetch Query`|L'operatore `Fetch Query` recupera le righe quando viene eseguita un'operazione di recupero in un cursore.|  
|![Icona dell'operatore Filter (motore di database)](../../2014/database-engine/media/filter-32x.gif "Icona dell'operatore Filter (motore di database)")|**Filter**|L'operatore **Filter** esegue l'analisi dell'input, restituendo solo le righe che soddisfano l'espressione di filtro (predicato) visualizzata nella `Argument` colonna.|  
|nessuno|`Flow Distinct`|L'operatore logico `Flow Distinct` esegue l'analisi dell'input e rimuove i valori duplicati. Mentre l' `Distinct` operatore utilizza tutti gli input prima di produrre un output, l'operatore **FlowDistinct** restituisce ogni riga ottenuta dall'input (a meno che la riga non sia un duplicato, nel qual caso viene scartata).|  
|nessuno|`Full Outer Join`|L'operatore logico `Full Outer Join` restituisce ogni riga che soddisfa il predicato di join del primo input (superiore) con ogni riga del secondo input (inferiore). L'operatore restituisce inoltre:<br /><br /> - Righe del primo input senza corrispondenze nel secondo input.<br /><br /> - Righe del secondo input senza corrispondenze nel primo input.<br /><br /> <br /><br /> L'input che non include valori corrispondenti viene restituito come valore Null. `Full Outer Join` è un operatore logico.|  
|![Icona dell'operatore Gather Streams Parallelism](../../2014/database-engine/media/parallelism-32x.gif "Icona dell'operatore Gather Streams Parallelism")|**Gather Streams**|L'operatore logico **Gather Streams** viene utilizzato esclusivamente in piani di query paralleli. **Tale operatore** elabora vari flussi di input e quindi produce un unico flusso di output di record derivati dalla combinazione dei flussi di input. Il contenuto e il formato del record non vengono modificati. Se l'operatore prevede l'ordinamento, è necessario che tutti i flussi di input siano ordinati. Se l'output è ordinato, la `Argument` colonna contiene un predicato order by:() e i nomi delle colonne ordinate. **Gather Streams** è un operatore logico.|  
|![Icona dell'operatore Hash Match](../../2014/database-engine/media/hash-match-32x.gif "Icona dell'operatore Hash Match")|`Hash Match`|L'operatore `Hash Match` compila una tabella hash calcolando un valore hash per ogni riga dall'input di compilazione. Un predicato HASH:() con un elenco di colonne usato per creare un valore hash viene visualizzato nella `Argument` colonna. Per ogni riga probe, quando applicabile, viene calcolato un valore hash (tramite la stessa funzione di hashing) e quindi vengono cercate corrispondenze nella tabella hash. Se è presente un predicato residuo (identificato da:() RESIDUo nella `Argument` colonna), il predicato deve essere soddisfatto anche affinché le righe vengano considerate corrispondenti. Il funzionamento dipende dell'operazione logica eseguita:<br /><br /> Per tutti i join, il primo input (superiore) viene utilizzato per la compilazione della tabella hash e il secondo input (inferiore) per l'esecuzione del probe nella tabella hash. L'output delle corrispondenze (o delle mancate corrispondenze) viene eseguito in base a quanto previsto dal tipo di join. Se più join utilizzano la stessa colonna di join, le operazioni sono raggruppate in un gruppo di hash.<br /><br /> Per gli operatori Distinct o Aggregate l'input viene utilizzato per la compilazione della tabella hash (con rimozione dei duplicati e calcolo di eventuali espressioni di aggregazione). Quando viene creata la tabella hash, vengono eseguiti l'analisi della tabella e il successivo output di tutte le voci.<br /><br /> Per l'operatore Union, il primo input viene utilizzato per la compilazione della tabella hash (con rimozione dei duplicati). Il secondo input (che non deve includere duplicati) viene utilizzato per l'esecuzione del probe della tabella hash, seguita dalla restituzione di tutte le righe senza corrispondenze, dall'analisi della tabella hash e infine dalla restituzione di tutte le voci.<br /><br /> <br /><br /> `Hash Match` è un operatore fisico.|  
|![Icona dell'elemento di linguaggio If](../../2014/database-engine/media/if-32x.gif "Icona dell'elemento di linguaggio If")|`If`|L'operatore `If` esegue un'elaborazione condizionale basata su un'espressione. `If` è un elemento di linguaggio.|  
|nessuno|`Inner Join`|L'operatore logico `Inner Join` restituisce ogni riga che soddisfa il join del primo input (superiore) con il secondo input (inferiore).|  
|![Icona dell'operatore Insert (motore di database)](../../2014/database-engine/media/insert-32x.gif "Icona dell'operatore Insert (motore di database)")|`Insert`|L' `Insert` operatore logico inserisce ogni riga dal relativo input nell'oggetto specificato nella `Argument` colonna. L'operatore fisico è l'operatore `Table Insert`, `Index Insert` o `Clustered Index Insert`.|  
|![Icona dell'operatore Inserted Scan](../../2014/database-engine/media/inserted-scan-32x.gif "Icona dell'operatore Inserted Scan")|**Inserted Scan**|L'operatore **Inserted Scan** esegue l'analisi della tabella **inserted** . **Inserted Scan** è un operatore logico e fisico.|  
|![Icona dell'elemento di linguaggio Intrinsic](../../2014/database-engine/media/intrinsic-32x.gif "Icona dell'elemento di linguaggio Intrinsic")|`Intrinsic`|L'operatore `Intrinsic` richiama una funzione [!INCLUDE[tsql](../includes/tsql-md.md)] interna. `Intrinsic` è un elemento di linguaggio.|  
|![Icona generica dell'operatore Catchall](../../2014/database-engine/media/iterator-catch-all.gif "Icona generica dell'operatore Catchall")|`Iterator`|L'icona generica per `Iterator` viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per i costrutti del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icona dell'operatore Bookmark Lookup](../../2014/database-engine/media/bookmark-lookup-32x.gif "Icona dell'operatore Bookmark Lookup")|`Key Lookup`|L' `Key Lookup` operatore è una ricerca di segnalibro in una tabella con un indice cluster. La `Argument` colonna contiene il nome dell'indice cluster e la chiave di clustering utilizzata per cercare la riga nell'indice cluster. `Key Lookup`è sempre accompagnato da un `Nested Loops` operatore. Se la clausola WITH PREFETCH viene visualizzata nella `Argument` colonna, query processor ha determinato che è ottimale utilizzare la prelettura asincrona (Read-Ahead) per la ricerca di segnalibri nell'indice cluster.<br /><br /> L'utilizzo di un `Key Lookup` operatore in un piano di query indica che la query può trarre vantaggio dall'ottimizzazione delle prestazioni. Le prestazioni della query, ad esempio, potrebbero essere migliorate con l'aggiunta di un indice di copertura.|  
|![Icona dell'operatore Keyset Cursor](../../2014/database-engine/media/keyset-32x.gif "Icona dell'operatore Keyset Cursor")|`Keyset`|L'operatore `Keyset` utilizza un cursore in grado di riconoscere gli aggiornamenti ma non gli inserimenti eseguiti da altri.|  
|![Icona generica di Language Element](../../2014/database-engine/media/language-construct-catch-all.gif "Icona generica di Language Element")|`Language Element`|L'icona generica per `Language Element` viene visualizzata quando la logica che produce Showplan grafici non è in grado di individuare un'icona appropriata per l'iteratore. L'icona generica non indica necessariamente una condizione di errore. Sono disponibili tre icone generiche: blu (per gli iteratori), arancione (per i cursori) e verde (per i costrutti del linguaggio [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icona dell'operatore Spool](../../2014/database-engine/media/spool-32x.gif "Icona dell'operatore Spool")|**Lazy Spool**|L'operatore logico **Lazy Spool** archivia ogni riga dell'input in un oggetto temporaneo nascosto archiviato nel `tempdb` database. Se l'operatore viene riavvolto (ad esempio, da un `Nested Loops` operatore) ma non è necessaria alcuna riassociazione, i dati di spooling vengono utilizzati al posto della ripetizione dell'analisi dell'input. Se è necessario ripetere l'associazione, i dati di spooling vengono eliminati e l'oggetto di spooling viene ricompilato tramite una nuova analisi dell'input riassociato. L'operatore **Lazy Spool** compila il file di spooling con un'elaborazione lenta: ogni volta che l'operatore padre dello spooling richiede una riga, anziché elaborare contemporaneamente tutte le righe, l'operatore di spooling ottiene una riga dal relativo operatore di input e la archivia nel file di spooling. Lazy Spool è un operatore logico.|  
|nessuno|`Left Anti Semi Join`|L'operatore `Left Anti Semi Join` restituisce ogni riga del primo input (superiore) alla quale non corrisponde nessuna riga del secondo input (inferiore). Se nella colonna non è presente alcun predicato di join `Argument` , ogni riga corrisponde a una riga corrispondente. `Left Anti Semi Join` è un operatore logico.|  
|nessuno|`Left Outer Join`|L'operatore `Left Outer Join` restituisce ogni riga che soddisfa il join del primo input (superiore) con il secondo input (inferiore). L'operatore restituisce inoltre ogni riga del primo input alla quale non corrisponde una riga nel secondo input. Le righe senza corrispondenza nel secondo input vengono restituite come valori Null. Se nella colonna non è presente alcun predicato di join `Argument` , ogni riga corrisponde a una riga corrispondente. `Left Outer Join` è un operatore logico.|  
|nessuno|`Left Semi Join`|L'operatore `Left Semi Join` restituisce ogni riga del primo input (superiore) alla quale corrisponde una riga del secondo input (inferiore). Se nella colonna non è presente alcun predicato di join `Argument` , ogni riga corrisponde a una riga corrispondente. `Left Semi Join` è un operatore logico.|  
|![Icona dell'operatore Log Row Scan](../../2014/database-engine/media/log-row-scan-32x.gif "Icona dell'operatore Log Row Scan")|`Log Row Scan`|L'operatore `Log Row Scan` esegue l'analisi del log delle transazioni. `Log Row Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Merge Interval](../../2014/database-engine/media/merge-interval-32x.gif "Icona dell'operatore Merge Interval")|`Merge Interval`|L'operatore `Merge Interval` unisce più intervalli (potenzialmente sovrapposti) e restituisce intervalli minimi non sovrapposti, utilizzati per la ricerca di voci di indice. Questo operatore viene in genere visualizzato sopra uno o più `Compute Scalar` operatori sugli `Constant Scan` operatori, che creano gli intervalli (rappresentati come colonne in una riga) Uniti da questo operatore. `Merge Interval` è un operatore logico e fisico.|  
|![Icona dell'operatore Merge Join](../../2014/database-engine/media/merge-join-32x.gif "Icona dell'operatore Merge Join")|**Merge join**|L'operatore **Merge Join** esegue le operazioni di inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join e union logical.<br /><br /> Nella `Argument` colonna l'operatore **merge join** contiene un predicato merge:() se l'operazione sta eseguendo un join uno-a-molti o un predicato merge:() many-to-many se l'operazione sta eseguendo un join molti-a-molti. La `Argument` colonna include inoltre un elenco delimitato da virgole di colonne utilizzate per eseguire l'operazione. L'operatore **Merge Join** richiede due input ordinati in base alle rispettive colonne, eventualmente tramite l'inserimento di operazioni di ordinamento esplicite nel piano di query. Merge Join è particolarmente efficace se non è richiesto l'ordinamento esplicito, ad esempio se nel database è presente un indice ad albero B adeguato o se il tipo di ordinamento è utilizzabile per più operazioni, quali merge join e raggruppamenti con rollup. **Merge Join** è un operatore fisico.|  
|![Icona dell'operatore Nested Loops](../../2014/database-engine/media/nested-loops-32x.gif "Icona dell'operatore Nested Loops")|`Nested Loops`|L'operatore `Nested Loops` esegue le operazioni logiche di inner join, left outer join, left semi join e left anti semi join. I join a cicli annidati eseguono una ricerca nella tabella interna per ogni riga della tabella esterna, usando generalmente un indice. Query processor determina, in base ai costi previsti, se ordinare l'input esterno per migliorare le ricerche basate sull'indice rispetto all'input interno. Tutte le righe che soddisfano il predicato (facoltativo) nella `Argument` colonna vengono restituite come applicabili, in base all'operazione logica eseguita. `Nested Loops` è un operatore fisico.|  
|![Icona dell'operatore Nonclustered Index Delete](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Icona dell'operatore Nonclustered Index Delete")|`Nonclustered Index Delete`|L' `Nonclustered Index Delete` operatore elimina le righe di input dall'indice non cluster specificato nella `Argument` colonna. `Nonclustered Index Delete` è un operatore fisico.|  
|![Icona dell'operatore Nonclustered Index Insert](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Icona dell'operatore Nonclustered Index Insert")|`Index Insert`|L' `Index Insert` operatore inserisce le righe dal relativo input nell'indice non cluster specificato nella `Argument` colonna. La colonna `Argument` contiene inoltre un predicato SET:(), che indica il valore su cui è impostata ogni colonna. `Index Insert` è un operatore fisico.|  
|![Icona dell'operatore Nonclustered Index Scan](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Icona dell'operatore Nonclustered Index Scan")|`Index Scan`|L' `Index Scan` operatore Recupera tutte le righe dall'indice non cluster specificato nella `Argument` colonna. Se nella colonna è presente un predicato WHERE:() facoltativo `Argument` , vengono restituite solo le righe che soddisfano il predicato. `Index Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Nonclustered Index Seek](../../2014/database-engine/media/index-seek-32x.gif "Icona dell'operatore Nonclustered Index Seek")|`Index Seek`|L'operatore `Index Seek` utilizza le funzionalità di ricerca degli indici per recuperare righe da un indice non cluster. La `Argument` colonna contiene il nome dell'indice non cluster utilizzato. La colonna include inoltre il predicato SEEK:(). Il motore di archiviazione utilizza l'indice per elaborare soltanto le righe conformi al predicato SEEK:() Facoltativamente esso può includere un predicato WHERE:(), che verrà valutato dal motore di archiviazione rispetto a tutte le righe conformi al predicato SEEK:() (non utilizza gli indici per tale operazione). Se la `Argument` colonna contiene la clausola ORDERED, query processor ha determinato che le righe devono essere restituite nell'ordine in cui l'indice non cluster le ha ordinate. In assenza della clausola ORDERED, il motore di archiviazione esegue una ricerca nell'indice utilizzando il metodo ottimale (con output non necessariamente ordinato). Il mantenimento dell'ordinamento dell'output può dare come risultato un livello di efficienza minore rispetto alla restituzione di output non ordinato. `Index Seek` è un operatore logico e fisico.|  
|![Icona dell'operatore Nonclustered Index Spool](../../2014/database-engine/media/index-spool-32x.gif "Icona dell'operatore Nonclustered Index Spool")|**Index Spool**|L'operatore fisico **Index Spool** contiene un predicato SEEK:() nella `Argument` colonna. L'operatore **Index Spool** esegue l'analisi delle righe di input, inserendo una copia di ogni riga in un file di spooling nascosto (archiviato nel `tempdb` database e esistente solo per la durata della query) e compila un indice non cluster sulle righe. Ciò consente di utilizzare la funzionalità di ricerca degli indici per restituire solo le righe che soddisfano il predicato SEEK:(). Se l'operatore viene riavvolto (ad esempio, da un `Nested Loops` operatore) ma non è necessaria alcuna riassociazione, i dati di spooling vengono utilizzati al posto della ripetizione dell'analisi dell'input.|  
|![Icona dell'operatore Nonclustered Index Update](../../2014/database-engine/media/nonclust-index-update-32x.gif "Icona dell'operatore Nonclustered Index Update")|`Nonclustered Index Update`|L' `Nonclustered Index Update` operatore fisico aggiorna le righe dal relativo input nell'indice non cluster specificato nella `Argument` colonna. Se è stato specificato un predicato SET:(), ogni colonna aggiornata viene impostata su tale valore. `Nonclustered Index Update` è un operatore fisico.|  
|![Icona dell'operatore Online Index Insert](../../2014/database-engine/media/online-index-32x.gif "Icona dell'operatore Online Index Insert")|**Online Index Insert**|L'operatore fisico **Online Index Insert** indica che la creazione, la modifica o l'eliminazione di un indice viene eseguita online, ovvero che i dati della tabella sottostante rimangono disponibili agli utenti durante l'operazione sull'indice.|  
|nessuno|`Parallelism`|L' `Parallelism` operatore esegue le operazioni logiche Distribute Streams, Gather Streams e Repartition Streams. Le `Argument` colonne possono contenere un predicato PARTITION COLUMNS:() con un elenco delimitato da virgole delle colonne partizionate. Le `Argument` colonne possono inoltre contenere un predicato order by:(), che elenca le colonne di cui mantenere l'ordinamento durante il partizionamento. `Parallelism` è un operatore fisico.<br /><br /> Nota: se una query è stata compilata come query parallela, ma in fase di esecuzione viene eseguita come query seriale, l'output Showplan generato da SET STATISTICs XML o tramite l'opzione **Includi piano di esecuzione effettivo** in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] non conterrà l' `RunTimeInformation` elemento per l' `Parallelism` operatore. Nell'output di SET STATISTICs PROFILE i conteggi delle righe effettivi e il numero effettivo di esecuzioni visualizzeranno zeri per l' `Parallelism` operatore. Quando si verifica una delle due condizioni, significa che l' `Parallelism` operatore è stato usato solo durante la compilazione della query e non nel piano di query di run-time. Si noti che talvolta i piani di query parallele vengono eseguiti in serie se il carico simultaneo del server è elevato.|  
|![Icona dell'operatore Parameter Table Scan](../../2014/database-engine/media/parameter-table-scan-32x.gif "Icona dell'operatore Parameter Table Scan")|`Parameter Table Scan`|L'operatore `Parameter Table Scan` esegue l'analisi di una tabella che funge da parametro nella query corrente. In genere questa funzionalità è utilizzata per le query INSERT all'interno di una stored procedure. `Parameter Table Scan` è un operatore logico e fisico.|  
|nessuno|**Partial Aggregate**|L'operatore**Partial Aggregate** è utilizzato nei piani paralleli. Applica una funzione di aggregazione al maggior numero possibile di righe di input in modo che la scrittura su disco (operazione nota come "spill") non sia necessaria. `Hash Match`è l'unico operatore fisico (iteratore) che implementa l'aggregazione delle partizioni. **Partial Aggregate** è un operatore logico.|  
|![Icona dell'operatore Population Query Cursor](../../2014/database-engine/media/poulation-query-32x.gif "Icona dell'operatore Population Query Cursor")|`Population Query`|All'apertura di un cursore, l'operatore `Population Query` esegue il popolamento della relativa tabella di lavoro.|  
|![Icona dell'operatore Refresh Query Cursor](../../2014/database-engine/media/refresh-query-32x.gif "Icona dell'operatore Refresh Query Cursor")|`Refresh Query`|L'operatore `Refresh Query` recupera i dati correnti per le righe nel buffer di recupero.|  
|![Icona dell'operatore Remote Delete](../../2014/database-engine/media/remote-delete-32x.gif "Icona dell'operatore Remote Delete")|`Remote Delete`|L'operatore `Remote Delete` elimina le righe di input da un oggetto remoto. `Remote Delete` è un operatore logico e fisico.|  
|![Operatore Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-scan-32x.gif "Operatore Showplan Remote Index Seek")|**Remote Index Scan**|L'operatore **Remote Index Scan** analizza l'indice remoto specificato nella colonna Argument. **Remote Insert Scan** è un operatore logico e fisico.|  
|![Operatore Showplan Remote Index Seek](../../2014/database-engine/media/remote-index-seek-32x.gif "Operatore Showplan Remote Index Seek")|**Remote Index Seek**|L'operatore **Remote Index Seek** utilizza le capacità di ricerca di un oggetto Index remoto per il recupero di righe. La `Argument` colonna contiene il nome dell'indice remoto usato e il predicato SEEK:(). **Remote Insert Seek** è un operatore logico fisico.|  
|![Icona dell'operatore Remote Insert](../../2014/database-engine/media/remote-insert-32x.gif "Icona dell'operatore Remote Insert")|**Remote Insert**|L'operatore **Remote Insert** inserisce le righe di input in un oggetto remoto. **Remote Insert** è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Query](../../2014/database-engine/media/remote-query-32x.gif "Icona dell'operatore Remote Query")|`Remote Query`|L'operatore `Remote Query` invia una query a un'origine remota. Il testo della query inviata al server remoto viene visualizzato nella `Argument` colonna. `Remote Query` è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Scan](../../2014/database-engine/media/remote-scan-32x.gif "Icona dell'operatore Remote Scan")|`Remote Scan`|L'operatore `Remote Scan` esegue l'analisi di un oggetto remoto. Il nome dell'oggetto remoto viene visualizzato nella `Argument` colonna. `Remote Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Remote Update](../../2014/database-engine/media/remote-update-32x.gif "Icona dell'operatore Remote Update")|`Remote Update`|L'operatore `Remote Update` aggiorna le righe di input in un oggetto remoto. `Remote Update` è un operatore logico e fisico.|  
|![Icona dell'operatore Repartition Streams Parallelism](../../2014/database-engine/media/parallelism-repartition-stream.gif "Icona dell'operatore Repartition Streams Parallelism")|**Repartition Streams**|L'operatore **Repartition Streams** elabora più flussi e restituisce più flussi di record. Il contenuto e il formato del record non vengono modificati. Se Query Optimizer utilizza un filtro bitmap, il numero di righe nel flusso di output è ridotto. Ogni record di un flusso di input viene inserito in un flusso di output. Se l'operatore prevede il rispetto dell'ordine, è necessario che tutti i flussi di input risultino ordinati e vengano uniti in vari flussi di output ordinati. Se l'output è partizionato, la `Argument` colonna contiene un predicato:() delle colonne di partizione e le colonne di partizionamento. Se l'output è ordinato, la `Argument` colonna contiene un predicato order by:() e le colonne ordinate. **Repartition Streams** è un operatore logico. L'operatore viene utilizzato solo nei piani di query parallele.|  
|![Icona dell'elemento di linguaggio Result](../../2014/database-engine/media/result-32x.gif "Icona dell'elemento di linguaggio Result")|`Result`|L'operatore `Result` corrisponde ai dati restituiti alla fine di un piano di query ed è in genere l'elemento radice di uno Showplan. `Result` è un elemento di linguaggio.|  
|![Icona dell'operatore RID Lookup](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "Icona dell'operatore RID Lookup")|`RID Lookup`|`RID Lookup` implementa la funzionalità di ricerca tramite segnalibro in un heap mediante un identificatore di riga (RID) che viene passato all'operatore. La `Argument` colonna contiene l'etichetta del segnalibro utilizzata per cercare la riga nella tabella e il nome della tabella in cui viene cercata la riga. `RID Lookup` è sempre utilizzato in combinazione con un operatore NESTED LOOP JOIN. `RID Lookup` è un operatore fisico. Per ulteriori informazioni sulle ricerche tramite segnalibro, vedere "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" nel blog su SQL Server in MSDN.|  
|nessuno|`Right Anti Semi Join`|L'operatore `Right Anti Semi Join` restituisce ogni riga del secondo input (inferiore) alla quale non corrisponde alcuna riga nel primo input (superiore). Una riga corrispondente è definita come una riga che soddisfa il predicato nella `Argument` colonna (se non esiste alcun predicato, ogni riga corrisponde a una riga corrispondente). `Right Anti Semi Join` è un operatore logico.|  
|nessuno|`Right Outer Join`|L'operatore logico `Right Outer Join` restituisce ogni riga che soddisfa il join del secondo input (inferiore) con ogni riga corrispondente del primo input (superiore). L'operatore restituisce inoltre ogni riga del secondo input alla quale non corrisponde una riga nel primo input, con join a valori NULL. Se nella colonna non è presente alcun predicato di join `Argument` , ogni riga corrisponde a una riga corrispondente. `Right Outer Join` è un operatore logico.|  
|nessuno|`Right Semi Join`|L'operatore `Right Semi Join` restituisce ogni riga del secondo input (inferiore) alla quale corrisponde una riga nel primo input (superiore). Se nella colonna non è presente alcun predicato di join `Argument` , ogni riga corrisponde a una riga corrispondente. `Right Semi Join` è un operatore logico.|  
|![Icona dell'operatore Row Count Spool](../../2014/database-engine/media/remote-count-spool-32x.gif "Icona dell'operatore Row Count Spool")|**Row Count Spool**|L'operatore **Row Count Spool** esegue l'analisi dell'input calcolando e restituendo il numero di righe presenti senza alcun dato. Questo operatore viene utilizzato quando è importante verificare l'esistenza delle righe anziché i dati contenuti nelle righe. Se, ad esempio, un `Nested Loops` operatore esegue un'operazione left semi join e il predicato di join viene applicato all'input interno, è possibile posizionare uno spool di conteggio delle righe nella parte superiore dell'input interno dell' `Nested Loops` operatore. L' `Nested Loops` operatore può quindi determinare il numero di righe restituite dallo spooler di conteggio delle righe (poiché i dati effettivi del lato interno non sono necessari) per determinare se restituire la riga esterna. **Row Count Spool** è un operatore fisico.|  
|![Icona dell'operatore Segment](../../2014/database-engine/media/segment-32x.gif "Icona dell'operatore Segment")|**Segmento**|**Segment** è un operatore fisico e logico L'operatore divide il set di input in segmenti in base al valore di una o più colonne Tali colonne vengono visualizzate come argomenti nell'operatore **Segment** e quindi restituisce un segmento per volta.|  
|nessuno|`Segment Repartition`|In un piano di query parallele sono presenti talvolta regioni concettuali di iteratori. È possibile eseguire tutti gli iteratori all'interno di tale regione mediante thread paralleli. Le regioni devono invece essere eseguite in modalità seriale. Alcuni iteratori `Parallelism` all'interno di una singola regione sono denominati `Branch Repartition`. L'operatore `Parallelism` al confine tra due regioni di questo tipo viene denominato `Segment Repartition`. `Branch Repartition` e `Segment Repartition` sono operatori logici.|  
|![Icona dell'operatore Sequence](../../2014/database-engine/media/sequence-32x.gif "Icona dell'operatore Sequence")|`Sequence`|L'operatore `Sequence` indirizza i piani di aggiornamento estesi. A livello funzionale l'operatore esegue ogni input in sequenza (dall'alto verso il basso). Ogni input è in genere un aggiornamento di un oggetto diverso. L'operatore restituisce soltanto le righe derivanti dall'ultimo input (inferiore). `Sequence` è un operatore logico e fisico.|  
|![Icona dell'operatore Sequence Project](../../2014/database-engine/media/sequence-project-32x.gif "Icona dell'operatore Sequence Project")|`Sequence Project`|L'operatore `Sequence Project` consente di aggiungere colonne per eseguire calcoli in un set ordinato. L'operatore divide il set di input in segmenti in base al valore di una o più colonne e quindi restituisce un segmento per volta. Tali colonne vengono visualizzate come argomenti nell'operatore `Sequence Project`. `Sequence Project` è un operatore logico e fisico.|  
|![Icona dell'operatore Snapshot Cursor](../../2014/database-engine/media/snapshot-32x.gif "Icona dell'operatore Snapshot Cursor")|**Snapshot**|L'operatore **Snapshot** crea un cursore che non consente di visualizzare le modifiche apportate da altri utenti.|  
|![Icona dell'operatore Sort](../../2014/database-engine/media/sort-32x.gif "Icona dell'operatore Sort")|`Sort`|L' `Sort` operatore ordina tutte le righe in ingresso. La `Argument` colonna contiene un predicato DISTINCT ORDER BY:() se i duplicati vengono rimossi da questa operazione o un predicato order by:() con un elenco delimitato da virgole delle colonne da ordinare. Alle colonne viene assegnato il prefisso ASC se sono ordinate in ordine crescente o il prefisso DESC se sono ordinate in ordine decrescente. `Sort` è un operatore logico e fisico.|  
|![Icona dell'operatore Split](../../2014/database-engine/media/split-32x.gif "Icona dell'operatore Split")|`Split`|L' `Split` operatore viene utilizzato per ottimizzare l'elaborazione degli aggiornamenti. Ogni operazione di aggiornamento viene suddivisa in un'operazione di eliminazione e un'operazione di inserimento. `Split` è un operatore logico e fisico.|  
|![Icona dell'operatore Spool](../../2014/database-engine/media/spool-32x.gif "Icona dell'operatore Spool")|**Spool**|L'operatore **spool** Salva il risultato di una query intermedia nel `tempdb` database.|  
|![Icona dell'operatore Stream Aggregate](../../2014/database-engine/media/stream-aggregate-32x.gif "Icona dell'operatore Stream Aggregate")|`Stream Aggregate`|L'operatore `Stream Aggregate` raggruppa le righe in base a una o più colonne e quindi calcola una o più espressioni di aggregazione restituite dalla query. L'output di questo operatore può essere utilizzato come riferimento da operatori successivi nella query, può essere restituito al client o può essere oggetto di entrambe le operazioni. Per l'operatore `Stream Aggregate` è necessario che l'input sia ordinato in base alle colonne all'interno del relativo gruppo. In Query Optimizer verrà utilizzato un operatore `Sort` prima di questo se i dati non sono già stati ordinati tramite un operatore `Sort` precedente o tramite una ricerca o un'analisi di un indice ordinato. Nell'istruzione SHOWPLAN_ALL o nel piano di esecuzione grafico in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] , le colonne nel predicato Group by sono elencate nella `Argument` colonna e le espressioni di aggregazione sono elencate nella colonna **valori definiti** . `Stream Aggregate` è un operatore fisico.|  
|![Icona dell'operatore Switch](../../2014/database-engine/media/switch-32x.gif "Icona dell'operatore Switch")|**Commutatore**|**Switch** è un tipo speciale di iteratore di concatenazione che prevede *n* input. A ogni operatore **Switch** è associata un'espressione. In base al valore restituito dall'espressione (compreso tra 0 e *n*-1), l'operatore **Switch** copia il flusso di input appropriato nel flusso di output. Tra i possibili utilizzi dell'operatore **Switch** è inclusa l'implementazione di query che richiedono cursori fast forward con operatori specifici, ad esempio l'operatore **TOP** . **Switch** è un operatore logico e fisico.|  
|![Icona dell'operatore Table Delete](../../2014/database-engine/media/table-delete-32x.gif "Icona dell'operatore Table Delete")|`Table Delete`|L' `Table Delete` operatore fisico Elimina righe dalla tabella specificata nella `Argument` colonna del piano di esecuzione della query.|  
|![Icona dell'operatore Table Insert](../../2014/database-engine/media/table-insert-32x.gif "Icona dell'operatore Table Insert")|`Table Insert`|L' `Table Insert` operatore inserisce le righe dal relativo input nella tabella specificata nella `Argument` colonna del piano di esecuzione della query. La colonna `Argument` contiene inoltre un predicato SET:(), che indica il valore su cui è impostata ogni colonna. Se in `Table Insert` non sono disponibili figli per i valori Insert, la riga inserita verrà recuperata dall'operatore Insert stesso. `Table Insert` è un operatore fisico.|  
|![Operatore Table Merge](../../2014/database-engine/media/table-merge-32x.gif "Operatore Table Merge")|**Table Merge**|L'operatore **Table Merge** applica un flusso di dati di unione a un heap. L'operatore Elimina, aggiorna o inserisce righe nella tabella specificata nella `Argument` colonna dell'operatore. L'operazione effettiva eseguita dipende dal valore di runtime della colonna **Action** specificata nella `Argument` colonna dell'operatore. **Table Merge** è un operatore fisico.|  
|![Icona dell'operatore Table Scan](../../2014/database-engine/media/table-scan-32x.gif "Icona dell'operatore Table Scan")|`Table Scan`|L' `Table Scan` operatore Recupera tutte le righe dalla tabella specificata nella `Argument` colonna del piano di esecuzione della query. Se nella colonna è presente un predicato WHERE:() `Argument` , vengono restituite solo le righe che soddisfano il predicato. `Table Scan` è un operatore logico e fisico.|  
|![Icona dell'operatore Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icona dell'operatore Table Spool")|**Table Spool**|L'operatore **Table Spool** esegue l'analisi dell'input e inserisce una copia di ogni riga in una tabella di spooling nascosta archiviata nel database [tempdb](../relational-databases/databases/tempdb-database.md) e con durata limitata alla durata della query. Se l'operatore viene riavvolto (ad esempio, da un `Nested Loops` operatore) ma non è necessaria alcuna riassociazione, i dati di spooling vengono utilizzati al posto della ripetizione dell'analisi dell'input. **Table Spool** è un operatore fisico.|  
|![Icona dell'operatore Table Update](../../2014/database-engine/media/table-update-32x.gif "Icona dell'operatore Table Update")|`Table Update`|L' `Table Update` operatore fisico aggiorna le righe di input nella tabella specificata nella `Argument` colonna del piano di esecuzione della query. Il predicato SET:() determina il valore di ogni colonna aggiornata. Un riferimento a tali valori può essere presente nella clausola SET o in altri punti dell'operatore o nella query.|  
|![Icona dell'operatore Table-valued Function](../../2014/database-engine/media/table-valued-function-32x.gif "Icona dell'operatore Table-valued Function")|**Funzione con valori di tabella**|L'operatore **Table-valued Function** valuta una funzione con valori di tabella ( [!INCLUDE[tsql](../includes/tsql-md.md)] o CLR) e archivia le righe risultanti nel database [tempdb](../relational-databases/databases/tempdb-database.md) . Quando gli iteratori padre richiedono le righe, la **funzione con valori di tabella** restituisce le righe da `tempdb` .<br /><br /> Le query con chiamate a funzioni con valori di tabella generano piani di query con l'iteratore **Table-valued Function** . **Table-valued Function** può essere valutato con valori di parametri diversi:<br /><br /> **Table-valued Function XML Reader** specifica come parametro di input un BLOB XML e produce un set di righe che rappresentano i nodi XML nell'ordine di un documento XML. Altri parametri di input possono limitare i nodi XML restituiti a un subset di un documento XML.<br /><br /> **Table Valued Function XML Reader con filtro XPath** è un tipo speciale di **XML Reader Table-valued Function** che limita l'output ai nodi XML che soddisfano un'espressione XPath.<br /><br /> <br /><br /> **Table-valued Function** è un operatore logico e fisico.|  
|![Icona dell'operatore Top](../../2014/database-engine/media/top-32x.gif "Icona dell'operatore Top")|**Inizio**|L'operatore **Top** esegue l'analisi dell'input e restituisce solo il primo numero o valore percentuale di righe specificato, eventualmente in base a un ordinamento. La `Argument` colonna può contenere un elenco delle colonne di cui è in corso il controllo dei vincoli. Nei piani di aggiornamento l'operatore **Top** consente di applicare limiti di conteggio righe. **Top** è un operatore logico e fisico. **Top** è un operatore logico e fisico.|  
|nessuno|**Top N Sort**|**Top n Sort** è simile all' `Sort` iteratore, con la differenza che sono necessarie solo le prime *n* righe e non l'intero set di risultati. Per valori bassi di *N*, il motore di esecuzione delle query di [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] prova a eseguire l'intera operazione di ordinamento in memoria. Nel caso di valori elevati di *N*, il motore di esecuzione delle query ricorre al metodo di ordinamento più generico in cui *N* non corrisponde a un parametro.|  
|![Icona di operatore esteso (UDX)](../../2014/database-engine/media/udx-32x.gif "Icona di operatore esteso (UDX)")|`UDX`|Gli operatori estesi (UDX) implementano una delle varie operazioni XQuery e XPath in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Tutti gli operatori UDX sono logici e fisici.<br /><br /> L'operatore esteso (UDX) `FOR XML` è utilizzato per serializzare gli input del set di righe relazionale nella rappresentazione XML in un'unica colonna BLOB in un'unica riga di output. È un operatore di aggregazione XML sensibile all'ordinamento.<br /><br /> L'operatore esteso (UDX) `XML SERIALIZER` è un operatore di aggregazione XML sensibile all'ordinamento. Inserisce righe che rappresentano nodi XML o valori scalari XQuery nell'ordine dei documenti XML e genera un BLOB XML serializzato in un'unica colonna XML in una singola colonna di output.<br /><br /> L'operatore esteso (UDX) `XML FRAGMENT SERIALIZER` è un particolare tipo di `XML SERIALIZER` utilizzato per l'elaborazione delle righe di input che rappresentano frammenti XML da inserire nell'estensione INSERT di XQuery per la modifica di dati.<br /><br /> L'operatore esteso (UDX) `XQUERY STRING` valuta il valore stringa XQuery delle righe di input che rappresentano i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il valore stringa dell'input.<br /><br /> L'operatore esteso (UDX) `XQUERY LIST DECOMPOSER` è un operatore di scomposizione di elenco XQuery. Per ogni riga di input che rappresenta un nodo XML, genera una o più righe, ognuna delle quali rappresenta un valore scalare XQuery che include un valore di voce di elenco se l'input è di tipo elenco XSD.<br /><br /> L'operatore esteso (UDX) `XQUERY DATA` valuta la funzione XQuery fn:data() rispetto all'input che rappresenta i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il risultato di **fn:data()**.<br /><br /> L'operatore esteso `XQUERY CONTAINS` valuta la funzione XQuery fn:contains() rispetto all'input che rappresenta i nodi XML. È un operatore di aggregazione di stringa sensibile all'ordinamento. Restituisce come output una riga con colonne che rappresentano il valore scalare XQuery che include il risultato di **fn:contains()**.<br /><br /> L'operatore esteso `UPDATE XML NODE` Aggiorna il nodo XML nell'estensione di modifica dei dati XQuery Replace nel metodo **Modify ()** sul tipo XML.|  
|nessuno|**Union**|L'operatore **Union** esegue l'analisi di più input e restituisce ogni riga sottoposta ad analisi rimuovendo i duplicati. L'operatore**Union** è un operatore logico.|  
|![Icona dell'operatore Update (motore di database)](../../2014/database-engine/media/update-32x.gif "Icona dell'operatore Update (motore di database)")|`Update`|L' `Update` operatore aggiorna ogni riga dal relativo input nell'oggetto specificato nella `Argument` colonna del piano di esecuzione della query. `Update` è un operatore logico. L'operatore fisico è `Table Update`, `Index Update` o `Clustered Index Update`.|  
|![Icona dell'elemento di linguaggio While](../../2014/database-engine/media/while-32x.gif "Icona dell'elemento di linguaggio While")|`While`|L'operatore `While` implementa il ciclo while di [!INCLUDE[tsql](../includes/tsql-md.md)]. `While` è un elemento di linguaggio.|  
|![Icona dell'operatore Table Spool](../../2014/database-engine/media/table-spool-32x.gif "Icona dell'operatore Table Spool")|`Window Spool`|L'operatore `Window Spool` espande ogni riga nel set di righe che rappresenta la finestra associata. In una query la clausola OVER definisce la finestra all'interno di un set di risultati della query, quindi una funzione della finestra calcola un valore per ogni riga della finestra stessa. `Window Spool` è un operatore logico e fisico.|  
  
  
