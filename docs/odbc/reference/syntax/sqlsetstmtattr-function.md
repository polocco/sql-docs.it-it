---
title: SQLSetStmtAttr (funzione) Documenti Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: dfbd2144e677d053f6154dfb3a1df1f6c25d9da5
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/14/2020
ms.locfileid: "81287264"
---
# <a name="sqlsetstmtattr-function"></a>Funzione SQLSetStmtAttr
**Conformità**  
 Versione introdotta: ODBC 3.0 Standards Compliance: ISO 92  
  
 **Riepilogo**  
 **SQLSetStmtAttr** imposta gli attributi correlati a un'istruzione.  
  
> [!NOTE]
>  Per ulteriori informazioni su ciò che Gestione Driver esegue il mapping di questa funzione a quando un'applicazione ODBC *3.x* utilizza un driver ODBC *2.x,* vedere Mapping di funzioni di sostituzione per la [compatibilità con](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md)le versioni precedenti delle applicazioni .  
  
## <a name="syntax"></a>Sintassi  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argomenti  
 *StatementHandle*  
 [Ingresso] Handle di istruzione.  
  
 *Attributo*  
 [Ingresso] Opzione per impostare, elencata in "Commenti".  
  
 *ValuePtr*  
 [Ingresso] Valore da *associare all'attributo*. A seconda del valore di *Attribute*, *ValuePtr* sarà uno dei seguenti:  
  
-   Handle del descrittore ODBC.  
  
-   Valore SQLUINTEGER.  
  
-   Valore SQLULEN.  
  
-   Puntatore a uno dei seguenti:  
  
    -   Stringa di caratteri con terminazione null.  
  
    -   Un buffer binario.  
  
    -   Valore o matrice di tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Valore definito dal driver.  
  
 Se l'argomento *Attributo* è un valore specifico del driver, *ValuePtr* può essere un intero con segno.  
  
 *Lunghezza stringa*  
 [Ingresso] Se *Attribute* è un attributo definito da ODBC e *ValuePtr* punta a una \*stringa di caratteri o a un buffer binario, questo argomento deve essere la lunghezza di *ValuePtr*. Se *Attributo* è un attributo definito da ODBC e *ValuePtr* è un numero intero, *StringLength* viene ignorato.  
  
 Se *Attribute* è un attributo definito dal driver, l'applicazione indica la natura dell'attributo a Gestione Driver impostando il *StringLength* argomento. *StringLength* può avere i valori seguenti:StringLength can have the following values:  
  
-   Se *ValuePtr* è un puntatore a una stringa di caratteri, *quindi StringLength* è la lunghezza della stringa o SQL_NTS.  
  
-   Se *ValuePtr* è un puntatore a un buffer binario, l'applicazione inserisce il risultato della macro SQL_LEN_BINARY_ATTR(*length*) in *StringLength*. In questo modo un valore negativo in *StringLength*.  
  
-   Se *ValuePtr* è un puntatore a un valore diverso da una stringa di caratteri o una stringa binaria, *quindi StringLength* deve avere il valore SQL_IS_POINTER.  
  
-   Se *ValuePtr* contiene un valore a lunghezza fissa, *StringLength* è SQL_IS_INTEGER o SQL_IS_UINTEGER, a seconda dei casi.  
  
## <a name="returns"></a>Valori di codice restituiti  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostica  
 Quando **SQLSetStmtAttr** restituisce SQL_ERROR o SQL_SUCCESS_WITH_INFO, è possibile ottenere un valore SQLSTATE associato chiamando **SQLGetDiagRec** con un *HandleType* di SQL_HANDLE_STMT e un *Handle* di *StatementHandle*. Nella tabella seguente sono elencati i valori SQLSTATE comunemente restituiti da **SQLSetStmtAttr** e vengono illustrati ognuno di essi nel contesto di questa funzione. la notazione "(DM)" precede le descrizioni di SQLSTATEs restituite da Gestione Driver. Il codice restituito associato a ogni valore SQLSTATE viene SQL_ERROR, se non specificato diversamente.  
  
|SQLSTATE|Errore|Descrizione|  
|--------------|-----------|-----------------|  
|01000|Avvertenza generale|Messaggio informativo specifico del driver. (Funzione restituisce SQL_SUCCESS_WITH_INFO.)|  
|01S02 (in questo stato di|Valore dell'opzione modificato|Il driver non supportava il valore specificato in *ValuePtr*o il valore specificato in *ValuePtr* non era valido a causa delle condizioni di lavoro di implementazione, pertanto il driver ha sostituito un valore simile. **SQLGetStmtAttr** può essere chiamato per determinare il valore sostituito temporaneamente. Il valore sostitutivo è valido per *il StatementHandle* fino a quando il cursore viene chiuso, a quel punto l'attributo di istruzione viene ripristinato il valore precedente. Gli attributi dell'istruzione che possono essere modificati sono:The statement attributes that can be changed are:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Funzione restituisce SQL_SUCCESS_WITH_INFO.)|  
|08S01|Errore di collegamento di comunicazione|Il collegamento di comunicazione tra il driver e l'origine dati a cui è stato connesso il driver non è riuscito prima che la funzione completasse l'elaborazione.|  
|24000|Stato del cursore non valido|*L'attributo* era SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS e il cursore era aperto.|  
|HY000|Errore generale:|Si è verificato un errore per il quale non è stato definito alcun SQLSTATE specifico e per il quale non è stato definito alcun SQLSTATE specifico dell'implementazione. Il messaggio di errore restituito da **SQLGetDiagRec** nel buffer * \*MessageText* descrive l'errore e la relativa causa.|  
|I001|Errore di allocazione della memoria|Il driver non è stato in grado di allocare la memoria necessaria per supportare l'esecuzione o il completamento della funzione.|  
|I009|Utilizzo non valido del puntatore null|L'argomento *Attribute* identifica un attributo di istruzione che richiedeva un attributo stringa e l'argomento *ValuePtr* era un puntatore null.|  
|HY010 (Informazioni in stati incomMIino in|Errore della sequenza di funzioni|(DM) è stata chiamata una funzione in modo asincrono in esecuzione per l'handle di connessione associato a *StatementHandle*. Questa funzione asincrona era ancora in esecuzione quando è stata chiamata la funzione **SQLSetStmtAttr.**<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**o **SQLMoreResults** è stato chiamato per *il StatementHandle* e restituito SQL_PARAM_DATA_AVAILABLE. Questa funzione è stata chiamata prima del recupero dei dati per tutti i parametri trasmessi.<br /><br /> (DM) una funzione in esecuzione in modo asincrono è stata chiamata per il *StatementHandle* ed era ancora in esecuzione quando questa funzione è stata chiamata.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**o **SQLSetPos** è stato chiamato per *StatementHandle* e ha restituito SQL_NEED_DATA. Questa funzione è stata chiamata prima dell'invio dei dati per tutti i parametri o le colonne data-at-execution.|  
|HY011|Impossibile impostare l'attributo ora|*L'attributo* era SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, ATTR_SIMULATE_CURSOR SQL_ o SQL_ ATTR_USE_BOOKMARKS e l'istruzione è stata preparata.|  
|HY013|Errore di gestione della memoria|Impossibile elaborare la chiamata di funzione perché non è stato possibile accedere agli oggetti di memoria sottostante, probabilmente a causa di condizioni di memoria insufficiente.|  
|HY017|Utilizzo non valido di un handle di descrittore allocato automaticamente|(DM) l'argomento *Attributo* è stato SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) l'argomento *Attribute* è stato SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC e il valore in *ValuePtr* era un handle di descrittore allocato in modo implicito diverso dall'handle allocato in origine per ARD o APD.|  
|HY024 (informazioni in base al|Valore dell'attributo non valido|Dato il valore *Attribute* specificato, è stato specificato un valore non valido in *ValuePtr*. Gestione Driver restituisce questo SQLSTATE solo per gli attributi di connessione e istruzione che accettano un set discreto di valori, ad esempio SQL_ATTR_ACCESS_MODE o SQL_ ATTR_ASYNC_ENABLE. Per tutti gli altri attributi di connessione e istruzione, il driver deve verificare il valore specificato in *ValuePtr*.)<br /><br /> L'argomento *Attribute* è stato SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC e *ValuePtr* era un handle di descrittore allocato in modo esplicito che non si trova sulla stessa connessione dell'argomento *StatementHandle.*|  
|I090|Stringa o lunghezza del buffer non valida|(DM) * \*ValuePtr* è una stringa di caratteri e l'argomento *StringLength* era minore di 0 ma non è stato SQL_NTS.|  
|I092 (informazioni in stato IN CUI|Identificatore di attributo/opzione non valido|(DM) il valore specificato per l'argomento *attributo* non è valido per la versione di ODBC supportata dal driver.<br /><br /> (DM) il valore specificato per l'argomento *Attributo* è un attributo di sola lettura.|  
|HY117|La connessione è sospesa a causa di uno stato di transazione sconosciuto. Sono consentite solo funzioni di disconnessione e di sola lettura.|(DM) Per ulteriori informazioni sullo stato sospeso, vedere [Funzione SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Funzionalità facoltativa non implementataOptional feature not implemented|Il valore specificato per l'argomento *attributo* è un attributo di istruzione ODBC valido per la versione di ODBC supportata dal driver, ma non è supportato dal driver.<br /><br /> Il *Attribute* argomento è stato SQL_ATTR_ASYNC_ENABLE e una chiamata a **SQLGetInfo** con un *InfoType* di SQL_ASYNC_MODE restituisce SQL_AM_CONNECTION.<br /><br /> L'argomento *Attribute* è stato SQL_ATTR_ENABLE_AUTO_IPD e il valore dell'attributo di connessione SQL_ATTR_AUTO_IPD è stato SQL_FALSE.|  
|HYT01|Timeout connessione scaduto|Il periodo di timeout della connessione è scaduto prima che l'origine dati riscisse risposta alla richiesta. Il periodo di timeout della connessione viene impostato tramite **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Il driver non supporta questa funzione|(DM) il driver associato a *StatementHandle* non supporta la funzione.|  
|S1118 (informazioni in due)|Driver non supporta la notifica asincrona|Se la chiamata a **SQLSetStmtAttr** per impostare SQL_ATTR_ASYNC_STMT_EVENT; la notifica asincrona non è supportata dal driver.|  
  
## <a name="comments"></a>Commenti  
 Gli attributi dell'istruzione per un'istruzione rimangono attivi fino a quando non vengono modificati da un'altra chiamata a **SQLSetStmtAttr** o fino a quando l'istruzione non viene eliminata chiamando **SQLFreeHandle**. La chiamata a **SQLFreeStmt** con l'opzione SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS non reimposta gli attributi dell'istruzione.  
  
 Alcuni attributi di istruzione supportano la sostituzione di un valore simile se l'origine dati non supporta il valore specificato in *ValuePtr*. In questi casi, il driver restituisce SQL_SUCCESS_WITH_INFO e SQLSTATE 01S02 (valore di opzione modificato). Ad esempio, se *Attribute* è SQL_ATTR_CONCURRENCY e *ValuePtr* è SQL_CONCUR_ROWVER e se l'origine dati non supporta questo, il driver sostituisce SQL_CONCUR_VALUES e restituisce SQL_SUCCESS_WITH_INFO. Per determinare il valore sostituito, un'applicazione chiama **SQLGetStmtAttr**.  
  
 Il formato delle informazioni impostate con *ValuePtr* dipende *dall'attributo*specificato. **SQLSetStmtAttr** accetta le informazioni sugli attributi in uno dei due formati diversi: una stringa di caratteri o un valore intero. Il formato di ciascuno è indicato nella descrizione dell'attributo. Questo formato si applica alle informazioni restituite per ogni attributo in **SQLGetStmtAttr**. Le stringhe di caratteri a cui fa riferimento l'argomento *ValuePtr* di **SQLSetStmtAttr** hanno una lunghezza di *StringLength*.  
  
> [!NOTE]
>  La possibilità di impostare gli attributi dell'istruzione a livello di connessione chiamando **SQLSetConnectAttr** è stata deprecata in ODBC *3.x*. Le applicazioni ODBC *3.x* non devono mai impostare gli attributi dell'istruzione a livello di connessione. Gli attributi dell'istruzione ODBC *3.x* non possono essere impostati a livello di connessione, ad eccezione degli attributi SQL_ATTR_METADATA_ID e SQL_ATTR_ASYNC_ENABLE, che sono entrambi attributi di connessione e attributi dell'istruzione e possono essere impostati a livello di connessione o di istruzione.  
> 
> [!NOTE]
>  I driver ODBC *3.x* devono supportare questa funzionalità solo se devono funzionare con le applicazioni ODBC *2.x* che impostano le opzioni dell'istruzione ODBC *2.x* a livello di connessione. Per altre informazioni, vedere "Impostazione delle opzioni di istruzione a livello di connessione" in [Mapping SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) nell'Appendice G: Linee guida per i driver per la compatibilità con le versioni precedenti.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributi dell'istruzione che impostano i campi del descrittore  
 Molti attributi di istruzione corrispondono a un campo di intestazione di un descrittore. L'impostazione di questi attributi comporta effettivamente l'impostazione dei campi del descrittore. L'impostazione dei campi tramite una chiamata a **SQLSetStmtAttr** anziché a **SQLSetDescField** presenta il vantaggio di non ottenere un handle del descrittore per la chiamata di funzione.  
  
> [!CAUTION]  
>  La chiamata a **SQLSetStmtAttr** per un'istruzione può influire su altre istruzioni. Ciò si verifica quando l'APD o ARD associato all'istruzione viene allocato in modo esplicito ed è anche associato ad altre istruzioni. Poiché **SQLSetStmtAttr** modifica APD o ARD, le modifiche si applicano a tutte le istruzioni a cui è associato questo descrittore. Se questo non è il comportamento richiesto, l'applicazione deve dissociare questo descrittore dalle altre istruzioni (chiamando **SQLSetStmtAttr** per impostare il SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC campo su un handle di descrittore diverso) prima di chiamare **sqlSetStmtAttr** nuovamente.  
  
 Quando un campo descrittore viene impostato come risultato dell'impostazione dell'attributo di istruzione corrispondente, il campo viene impostato solo per i descrittori applicabili attualmente associati all'istruzione identificata dall'argomento *StatementHandle* e l'impostazione dell'attributo non influisce sui descrittori che potrebbero essere associati a tale istruzione in futuro. Quando un campo descrittore che è anche un attributo di istruzione viene impostato da una chiamata a **SQLSetDescField**, viene impostato l'attributo di istruzione corrispondente. Se un descrittore allocato in modo esplicito viene dissociato da un'istruzione, un attributo di istruzione che corrisponde a un campo di intestazione verrà ripristinato il valore del campo nel descrittore allocato in modo implicito.  
  
 Quando viene allocata un'istruzione (vedere [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quattro handle di descrittore vengono allocati automaticamente e associati all'istruzione. Gli handle di descrittore allocati in modo esplicito possono essere associati all'istruzione chiamando **SQLAllocHandle** con *un fHandleType* di SQL_HANDLE_DESC per allocare un handle di descrittore e quindi chiamando **SQLSetStmtAttr** per associare l'handle del descrittore all'istruzione.  
  
 Gli attributi dell'istruzione nella tabella seguente corrispondono ai campi di intestazione del descrittore.  
  
|Attributo istruzione|Campo di intestazione|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Ard|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Ard|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Ard|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ard|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|Ird|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|Ird|  
  
## <a name="statement-attributes"></a>Attributi di istruzione  
 Gli attributi attualmente definiti e la versione di ODBC in cui sono stati introdotti sono illustrati nella tabella seguente. si prevede che più attributi saranno definiti dai driver per sfruttare le diverse origini dati. Un intervallo di attributi è riservato da ODBC; gli sviluppatori di driver devono riservare i valori per il proprio utilizzo specifico del driver da Open Group. Per ulteriori informazioni, vedere [Tipi di dati specifici del driver, Tipi di descrittore, Tipi di informazioni, Tipi di diagnostica e Attributi](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attributo|*Contenuto ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Handle per APD per le chiamate successive a **SQLExecute** e **SQLExecDirect** sull'handle dell'istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito quando l'istruzione è stata allocata inizialmente. Se il valore di questo attributo è impostato su SQL_NULL_DESC o l'handle originariamente allocato per il descrittore, un handle APD allocato in modo esplicito che è stato precedentemente associato all'handle di istruzione viene dissociato da esso e l'handle dell'istruzione viene ripristinato l'handle APD allocato in modo implicito.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o su un altro handle di descrittore impostato in modo implicito nella stessa istruzione. Gli handle di descrittore allocati in modo implicito non possono essere associati a più di un handle di istruzione o descrittore.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Handle per l'ARD per le ricuperi successivi sull'handle dell'istruzione. Il valore iniziale di questo attributo è il descrittore allocato in modo implicito quando l'istruzione è stata allocata inizialmente. Se il valore di questo attributo è impostato su SQL_NULL_DESC o l'handle allocato in origine per il descrittore, un handle ARD allocato in modo esplicito che è stato precedentemente associato all'handle di istruzione viene dissociato da esso e l'handle di istruzione viene ripristinato l'handle ARD allocato in modo implicito.<br /><br /> Questo attributo non può essere impostato su un handle di descrittore allocato in modo implicito per un'altra istruzione o su un altro handle di descrittore impostato in modo implicito nella stessa istruzione. Gli handle di descrittore allocati in modo implicito non possono essere associati a più di un handle di istruzione o descrittore.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Valore SQLULEN che specifica se una funzione chiamata con l'istruzione specificata viene eseguita in modo asincrono:<br /><br /> SQL_ASYNC_ENABLE_OFF: disabilita il supporto dell'esecuzione asincrona a livello di istruzione (impostazione predefinita).<br /><br /> SQL_ASYNC_ENABLE_ON: abilitare il supporto dell'esecuzione asincrona a livello di istruzione.<br /><br /> Per ulteriori informazioni, vedere [esecuzione asincrona (metodo polling)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Per i driver con supporto dell'esecuzione asincrona a livello di istruzione, l'attributo dell'istruzione SQL_ATTR_ASYNC_ENABLE è di sola lettura. Il valore è uguale al valore dell'attributo del livello di connessione con lo stesso nome al momento dell'allocazione dell'handle dell'istruzione.<br /><br /> La chiamata a **SQLSetStmtAttr** per impostare SQL_ATTR_ASYNC_ENABLE quando il SQL_ASYNC_MODE *InfoType* restituisce SQL_AM_CONNECTION restituisce SQLSTATE HYC00 (funzionalità facoltativa non implementata). Per altre informazioni, vedere [Funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) per altre informazioni.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Valore SQLPOINTER che è un handle di evento.<br /><br /> La notifica del completamento delle funzioni asincrone viene abilitata chiamando **SQLSetStmtAttr** per impostare l'attributo **SQL_ATTR_ASYNC_STMT_EVENT** e specificare l'handle dell'evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Oggetto SQLPOINTER alla funzione di callback asincrona.<br /><br /> Solo Gestione Driver può chiamare la funzione **SQLSetStmtAttr** di un driver con questo attributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Oggetto SQLPOINTER alla struttura del contesto<br /><br /> Solo Gestione Driver può chiamare la funzione **SQLSetStmtAttr** di un driver con questo attributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Valore SQLULEN che specifica la concorrenza del cursore:An SQLULEN value that specifies the cursor concurrency:<br /><br /> SQL_CONCUR_READ_ONLY: il cursore è di sola lettura. Non sono consentiti aggiornamenti.<br /><br /> SQL_CONCUR_LOCK cursore utilizza il livello più basso di blocco sufficiente per garantire che la riga può essere aggiornata.<br /><br /> SQL_CONCUR_ROWVER: il cursore utilizza il controllo della concorrenza ottimistica, confrontando le versioni di riga, ad esempio SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES: il cursore utilizza il controllo della concorrenza ottimistica, confrontando i valori.<br /><br /> Il valore predefinito per SQL_ATTR_CONCURRENCY è SQL_CONCUR_READ_ONLY.<br /><br /> Questo attributo non può essere specificato per un cursore aperto. Per ulteriori informazioni, vedere [Tipi di concorrenza](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Se *l'attributo* SQL_ATTR_CURSOR_TYPE viene modificato in un tipo che non supporta il valore corrente di SQL_ATTR_CONCURRENCY, il valore di SQL_ATTR_CONCURRENCY verrà modificato in fase di esecuzione e verrà generato un avviso quando viene chiamato **SQLExecDirect** o **SQLPrepare.**<br /><br /> Se il driver supporta l'istruzione **SELECT FOR UPDATE** e tale istruzione viene eseguita mentre il valore di SQL_ATTR_CONCURRENCY è impostato su SQL_CONCUR_READ_ONLY, verrà restituito un errore. Se il valore di SQL_ATTR_CONCURRENCY viene modificato in un valore che il driver supporta per un valore di SQL_ATTR_CURSOR_TYPE ma non per il valore corrente di SQL_ATTR_CURSOR_TYPE, il valore di SQL_ATTR_CURSOR_TYPE verrà modificato in fase di esecuzione e SQLSTATE 01S02 (valore Option modificato) viene generato quando viene chiamato **SQLExecDirect** o **SQLPrepare.**<br /><br /> Se la concorrenza specificata non è supportata dall'origine dati, il driver sostituisce una concorrenza diversa e restituisce SQLSTATE 01S02 (valore opzione modificato). Ad SQL_CONCUR_VALUES, il driver sostituisce SQL_CONCUR_ROWVER e viceversa. Ad SQL_CONCUR_LOCK, il conducente sostituisce, nell'ordine, SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES. La validità del valore sostituito non viene controllata fino al tempo di esecuzione.<br /><br /> Per ulteriori informazioni sulla relazione tra SQL_ATTR_CONCURRENCY e gli altri attributi del cursore, vedere [Caratteristiche del cursore e Tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Valore SQLULEN che specifica il livello di supporto richiesto dall'applicazione. L'impostazione di questo attributo influisce sulle chiamate successive a **SQLExecDirect** e **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE: i cursori scorrevoli non sono necessari sull'handle dell'istruzione. Se l'applicazione chiama **SQLFetchScroll** su questo handle, l'unico valore valido di *FetchOrientation* è SQL_FETCH_NEXT. Questa è la modalità predefinita.<br /><br /> SQL_SCROLLABLE: sono necessari cursori scorrevoli sull'handle dell'istruzione. Quando si chiama **SQLFetchScroll**, l'applicazione può specificare qualsiasi valore valido di *FetchOrientation*, ottenendo il posizionamento del cursore in modalità diverse dalla modalità sequenziale.<br /><br /> Per ulteriori informazioni sui cursori scorrevoli, consultate [Cursori scorrevoli.](../../../odbc/reference/develop-app/scrollable-cursors.md) Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_SCROLLABLE e gli altri attributi del cursore, vedere [Caratteristiche del cursore e tipo di cursoreFor more](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md) information about the relationship between SQL_ATTR_CURSOR_SCROLLABLE and the other cursor characteristics, see Cursor Characteristics and Cursor Type|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Valore SQLULEN che specifica se i cursori sull'handle dell'istruzione rendono visibili le modifiche apportate a un set di risultati da un altro cursore. L'impostazione di questo attributo influisce sulle chiamate successive a **SQLExecDirect** e **SQLExecute**. Un'applicazione può leggere il valore di questo attributo per ottenere lo stato iniziale o lo stato impostato più di recente dall'applicazione.<br /><br /> SQL_UNSPECIFIED: non è specificato il tipo di cursore e se i cursori sull'handle dell'istruzione rendono visibili le modifiche apportate a un set di risultati da un altro cursore. I cursori sull'handle dell'istruzione possono rendere visibili nessuna, alcune o tutte queste modifiche. Questa è la modalità predefinita.<br /><br /> SQL_INSENSITIVE: tutti i cursori sull'handle dell'istruzione mostrano il set di risultati senza riflettere le modifiche apportate da qualsiasi altro cursore. I cursori non sensibili sono di sola lettura. Corrisponde a un cursore statico, che ha una concorrenza di sola lettura.<br /><br /> SQL_SENSITIVE: tutti i cursori sull'handle dell'istruzione rendono visibili tutte le modifiche apportate a un set di risultati da un altro cursore.<br /><br /> Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_SENSITIVITY e gli altri attributi del cursore, vedere [Caratteristiche del cursore e Tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Valore SQLULEN che specifica il tipo di cursore:<br /><br /> SQL_CURSOR_FORWARD_ONLY- Il cursore scorre solo in avanti.<br /><br /> SQL_CURSOR_STATIC: i dati nel set di risultati sono statici.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN: il driver salva e utilizza le chiavi per il numero di righe specificato nell'attributo di istruzione SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC: il driver salva e utilizza solo le chiavi per le righe nel set di righe.<br /><br /> Il valore predefinito è SQL_CURSOR_FORWARD_ONLY. Questo attributo non può essere specificato dopo la preparazione dell'istruzione SQL.<br /><br /> Se il tipo di cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo di cursore diverso e restituisce SQLSTATE 01S02 (valore opzione modificato). Per un cursore misto o dinamico, il driver sostituisce, nell'ordine, un cursore statico o basato su keyset. Per un cursore basato su keyset, il driver sostituisce un cursore statico.<br /><br /> Per ulteriori informazioni sui tipi di cursore scorrevoli, vedere [Tipi di cursore scorrevoli](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Per ulteriori informazioni sulla relazione tra SQL_ATTR_CURSOR_TYPE e gli altri attributi del cursore, vedere [Caratteristiche del cursore e Tipo di cursore](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Valore SQLULEN che specifica se viene eseguito il popolamento automatico dell'IPD:<br /><br /> SQL_TRUE: attiva il popolamento automatico dell'IPD dopo una chiamata a **SQLPrepare**. SQL_FALSE: disattiva il popolamento automatico dell'IPD dopo una chiamata a **SQLPrepare**. Un'applicazione può comunque ottenere informazioni sui campi IPD chiamando **SQLDescribeParam**, se supportato. Il valore predefinito dell'attributo SQL_ATTR_ENABLE_AUTO_IPD dell'istruzione è SQL_FALSE. Per ulteriori informazioni, vedere [Popolamento automatico dell'IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Oggetto SQLLEN \* che punta a un valore di segnalibro binario. Quando **SQLFetchScroll** viene chiamato con *fFetchOrientation* uguale a SQL_FETCH_BOOKMARK, il driver preleva il valore del segnalibro da questo campo. Il valore predefinito di questo campo è un puntatore null. Per ulteriori informazioni, consultate Scorrimento in base al [segnalibro.](../../../odbc/reference/develop-app/scrolling-by-bookmark.md)<br /><br /> Il valore a cui fa riferimento questo campo non viene utilizzato per l'eliminazione da segnalibro, l'aggiornamento tramite segnalibro o il recupero da operazioni di segnalibro in **SQLBulkOperations**, che utilizzano segnalibri memorizzati nella cache nei buffer del set di righe.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Handle per l'IPD. Il valore di questo attributo è il descrittore allocato quando l'istruzione è stata allocata inizialmente. L'applicazione non può impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Handle per l'IRD. Il valore di questo attributo è il descrittore allocato quando l'istruzione è stata allocata inizialmente. L'applicazione non può impostare questo attributo.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Oggetto SQLULEN che specifica il numero di righe nel keyset per un cursore basato su keyset. Se la dimensione del keyset è 0 (impostazione predefinita), il cursore è completamente basato su keyset. Se la dimensione del keyset è maggiore di 0, il cursore viene misto (basato su keyset all'interno del keyset e dinamico all'esterno del keyset). La dimensione predefinita del keyset è 0.The default keyset size is 0. Per ulteriori informazioni sui cursori basati su [keyset, consultate Cursori basati su keyset.](../../../odbc/reference/develop-app/keyset-driven-cursors.md)<br /><br /> Se la dimensione specificata supera la dimensione massima del set di chiavi, il driver sostituisce tale dimensione e restituisce SQLSTATE 01S02 (valore opzione modificato).<br /><br /> **SQLFetch** o **SQLFetchScroll** restituisce un errore se la dimensione del set di chiavi è maggiore di 0 e minore della dimensione del set di righe.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Valore SQLULEN che specifica la quantità massima di dati restituiti dal driver da un carattere o da una colonna binaria. Se *ValuePtr* è minore della lunghezza dei dati disponibili, **SQLFetch** o **SQLGetData** tronca i dati e restituisce SQL_SUCCESS. Se *ValuePtr* è 0 (impostazione predefinita), il driver tenta di restituire tutti i dati disponibili.<br /><br /> Se la lunghezza specificata è inferiore alla quantità minima di dati che l'origine dati può restituire o maggiore della quantità massima di dati che l'origine dati può restituire, il driver sostituisce tale valore e restituisce SQLSTATE 01S02 (valore di opzione modificato).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto; Tuttavia, l'impostazione potrebbe non avere effetto immediato, nel qual caso il driver restituirà SQLSTATE 01S02 (valore opzione modificato) e reimposterà l'attributo sul valore originale.<br /><br /> Questo attributo ha lo scopo di ridurre il traffico di rete e deve essere supportato solo quando l'origine dati (a differenza del driver) in un driver a più livelli può implementarlo. Questo meccanismo non deve essere utilizzato dalle applicazioni per troncare i dati; Per troncare i dati ricevuti, un'applicazione deve specificare la lunghezza massima del buffer nell'argomento *BufferLength* in **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Valore SQLULEN corrispondente al numero massimo di righe da restituire all'applicazione per un'istruzione **SELECT.** Se \* *ValuePtr* è uguale a 0 (impostazione predefinita), il driver restituisce tutte le righe.<br /><br /> Questo attributo ha lo scopo di ridurre il traffico di rete. Concettualmente, viene applicato quando viene creato il set di risultati e limita il set di risultati alle prime righe ValuePtr.Conceptually, it is applied when the result set is created and limits the result set to the first *ValuePtr* rows. Se il numero di righe nel set di risultati è maggiore di *ValuePtr*, il set di risultati viene troncato.<br /><br /> SQL_ATTR_MAX_ROWS si applica a tutti i set di risultati *nell'istruzione*, inclusi quelli restituiti dalle funzioni di catalogo. SQL_ATTR_MAX_ROWS stabilisce un valore massimo per il valore del conteggio delle righe del cursore.<br /><br /> Un driver non deve emulare SQL_ATTR_MAX_ROWS comportamento per **SQLFetch** o **SQLFetchScroll** (se non è possibile implementare limitazioni di dimensione del set di risultati nell'origine dati) se non può garantire che SQL_ATTR_MAX_ROWS verrà implementato correttamente.<br /><br /> È definito dal driver se SQL_ATTR_MAX_ROWS si applica a istruzioni diverse dalle istruzioni SELECT (ad esempio le funzioni di catalogo).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto; Tuttavia, l'impostazione potrebbe non avere effetto immediato, nel qual caso il driver restituirà SQLSTATE 01S02 (valore opzione modificato) e reimposterà l'attributo sul valore originale.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Valore SQLULEN che determina la modalità di gestione degli argomenti stringa delle funzioni di catalogo.<br /><br /> Se SQL_TRUE, l'argomento stringa delle funzioni di catalogo viene considerato come identificatori. Il caso non è significativo. Per le stringhe non delimitate, il driver rimuove tutti gli spazi finali e la stringa viene piegata in maiuscolo. Per le stringhe delimitate, il driver rimuove tutti gli spazi iniziali o finali e accetta tutto ciò che è tra i delimitatori letteralmente. Se uno di questi argomenti è impostato su un puntatore null, la funzione restituisce SQL_ERROR e SQLSTATE HY009 (utilizzo non valido del puntatore null).<br /><br /> Se SQL_FALSE, gli argomenti stringa delle funzioni di catalogo non vengono considerati come identificatori. Il caso è significativo. Possono contenere o meno un criterio di ricerca di stringa, a seconda dell'argomento.<br /><br /> Il valore predefinito è SQL_FALSE.<br /><br /> L'argomento *TableType* di **SQLTables**, che accetta un elenco di valori, non è interessato da questo attributo.<br /><br /> SQL_ATTR_METADATA_ID può essere impostata anche a livello di connessione. (It e SQL_ATTR_ASYNC_ENABLE sono gli unici attributi di istruzione che sono anche attributi di connessione.)<br /><br /> Per ulteriori informazioni, vedere [Argomenti nelle funzioni di catalogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Valore SQLULEN che indica se il driver deve eseguire la scansione di stringhe SQL per le sequenze di escape:An SQLULEN value that indicates whether the driver should scan SQL strings for escape sequences:<br /><br /> SQL_NOSCAN_OFF: il driver analizza le stringhe SQL per le sequenze di escape (impostazione predefinita).<br /><br /> SQL_NOSCAN_ON- Il driver non analizza le stringhe SQL per le sequenze di escape. Al contrario, il driver invia l'istruzione direttamente all'origine dati.<br /><br /> Per ulteriori informazioni, vedere Sequenze di [escape in ODBC.](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md)|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Valore SQLULEN che punta a un offset aggiunto ai puntatori per modificare l'associazione dei parametri dinamici. Se questo campo non è null, il driver dereferenzia il puntatore, aggiunge il valore dereferenziato a ciascuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e utilizza i nuovi valori del puntatore durante l'associazione. È impostato su null per impostazione predefinita.<br /><br /> L'offset di associazione viene sempre aggiunto direttamente ai campi SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR. Se l'offset viene modificato in un valore diverso, il nuovo valore viene comunque aggiunto direttamente al valore nel campo del descrittore. Il nuovo offset non viene aggiunto al valore del campo più gli offset precedenti.<br /><br /> Per ulteriori informazioni, vedere [Offset di associazione dei parametri](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Valore SQLULEN che indica l'orientamento dell'associazione da utilizzare per i parametri dinamici.<br /><br /> Questo campo è impostato su SQL_PARAM_BIND_BY_COLUMN (impostazione predefinita) per selezionare l'associazione per colonna.<br /><br /> Per selezionare l'associazione per riga, questo campo viene impostato sulla lunghezza della struttura o su un'istanza di un buffer che verrà associato a un set di parametri dinamici. Questa lunghezza deve includere spazio per tutti i parametri associati e qualsiasi riempimento della struttura o del buffer per garantire che quando l'indirizzo di un parametro associato viene incrementato con la lunghezza specificata, il risultato punterà all'inizio dello stesso parametro nel set di parametri successivo. Quando si utilizza l'operatore *sizeof* in ANSI C, questo comportamento è garantito.<br /><br /> Per ulteriori informazioni, vedere [Associazione di matrici di parametri](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo BIND_TYPE SQL_DESC_ nell'intestazione APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT utilizzati per ignorare un parametro durante l'esecuzione di un'istruzione SQL. Ogni valore è impostato su SQL_PARAM_PROCEED (per il parametro da eseguire) o SQL_PARAM_IGNORE (per il parametro da ignorare).<br /><br /> Un set di parametri può essere ignorato durante l'elaborazione impostando il valore di stato nella matrice a cui fa riferimento SQL_DESC_ARRAY_STATUS_PTR nell'oggetto APD su SQL_PARAM_IGNORE. Un set di parametri viene elaborato se il relativo valore di stato è impostato su SQL_PARAM_PROCEED o se non è impostato alcun elemento nella matrice.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato del parametro. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva chiamata **a SQLExecDirect** o **SQLExecute.**<br /><br /> Questo attributo viene ignorato quando non è presente alcun parametro associato.<br /><br /> Per ulteriori informazioni, vedere [Utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT contenente informazioni sullo stato per ogni riga di valori di parametro dopo una chiamata a **SQLExecute** o **SQLExecDirect**. Questo campo è obbligatorio solo se PARAMSET_SIZE è maggiore di 1.<br /><br /> I valori di stato possono contenere i seguenti valori:<br /><br /> SQL_PARAM_SUCCESS: l'istruzione SQL è stata eseguita correttamente per questo set di parametri.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: l'istruzione SQL è stata eseguita correttamente per questo set di parametri. tuttavia, le informazioni di avviso sono disponibili nella struttura dei dati di diagnostica.<br /><br /> SQL_PARAM_ERROR: si è verificato un errore durante l'elaborazione di questo set di parametri. Ulteriori informazioni sull'errore sono disponibili nella struttura dei dati di diagnostica.<br /><br /> SQL_PARAM_UNUSED: questo set di parametri non è stato utilizzato, probabilmente a causa del fatto che alcuni set di parametri precedenti hanno causato un errore che ha interrotto l'ulteriore elaborazione o perché SQL_PARAM_IGNORE è stato impostato per tale set di parametri nella matrice specificata dal SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: il driver considera le matrici di parametri come un'unità monolitica e pertanto non genera questo livello di informazioni sull'errore.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato del parametro. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva chiamata a **SQLExecute** o **SQLExecDirect.** Si noti che l'impostazione di questo attributo può influire sul comportamento del parametro di output implementato dal driver.<br /><br /> Per ulteriori informazioni, vedere [Utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un campo \* di record SQLULEN che punta a un buffer in cui restituire il numero di set di parametri che sono stati elaborati, inclusi i set di errori. Se si tratta di un puntatore null, non verrà restituito alcun numero.<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IPD.<br /><br /> Se la chiamata a **SQLExecDirect** o **SQLExecute** che riempie il buffer a cui fa riferimento questo attributo non restituisce SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.<br /><br /> Per ulteriori informazioni, vedere [Utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Valore SQLULEN che specifica il numero di valori per ogni parametro. Se SQL_ATTR_PARAMSET_SIZE è maggiore di 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR di aPD puntano alle matrici. La cardinalità di ogni matrice è uguale al valore di questo campo.<br /><br /> Questo attributo viene ignorato quando non è presente alcun parametro associato.<br /><br /> Per ulteriori informazioni, vedere [Utilizzo di matrici di parametri](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Valore SQLULEN corrispondente al numero di secondi di attesa per l'esecuzione di un'istruzione SQL prima di tornare all'applicazione. Se *ValuePtr* è uguale a 0 (impostazione predefinita), non vi è alcun timeout.<br /><br /> Se il timeout specificato supera il timeout massimo nell'origine dati o è inferiore al timeout minimo, **SQLSetStmtAttr** sostituisce tale valore e restituisce SQLSTATE 01S02 (valore dell'opzione modificato).<br /><br /> Si noti che l'applicazione non è necessario chiamare **SQLCloseCursor** per riutilizzare l'istruzione se si è verificato il timeout di un'istruzione **SELECT.**<br /><br /> Il timeout della query impostato in questo attributo di istruzione è valido in entrambe le modalità sincrone e asincrone.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Un valore SQLULEN:<br /><br /> SQL_RD_ON **SQLFetchScroll** e, in ODBC *3.x,* **SQLFetch** recupera i dati dopo aver posizionato il cursore nella posizione specificata. Questa è la modalità predefinita.<br /><br /> SQL_RD_OFF **SQLFetchScroll** e, in ODBC *3.x,* **SQLFetch** non recuperano i dati dopo aver posizionato il cursore.<br /><br /> Impostando SQL_RETRIEVE_DATA su SQL_RD_OFF, un'applicazione può verificare l'esizione di una riga o recuperare un segnalibro per la riga senza incorrere nell'overhead del recupero delle righe. Per ulteriori informazioni, vedere [Scorrimento e recupero di righe](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Il valore di questo attributo può essere impostato su un cursore aperto; Tuttavia, l'impostazione potrebbe non avere effetto immediato, nel qual caso il driver restituirà SQLSTATE 01S02 (valore opzione modificato) e reimposterà l'attributo sul valore originale.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Valore SQLULEN che specifica il numero di righe restituite da ogni chiamata a **SQLFetch** o **SQLFetchScroll**. È anche il numero di righe in una matrice di segnalibri utilizzata in un'operazione di segnalibro in blocco in **SQLBulkOperations**. Il valore predefinito è 1.<br /><br /> Se la dimensione del set di righe specificata supera la dimensione massima del set di righe supportata dall'origine dati, il driver sostituisce tale valore e restituisce SQLSTATE 01S02 (valore opzione modificato).<br /><br /> Per ulteriori informazioni, vedere [Dimensione del set di righe](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_SIZE nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Valore SQLULEN che punta a un offset aggiunto ai puntatori per modificare l'associazione dei dati della colonna. Se questo campo non è null, il driver dereferenzia il puntatore, aggiunge il valore dereferenziato a ciascuno dei campi posticipati nel record del descrittore (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR e SQL_DESC_OCTET_LENGTH_PTR) e utilizza i nuovi valori del puntatore durante l'associazione. È impostato su null per impostazione predefinita.<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_BIND_OFFSET_PTR nell'intestazione ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Valore SQLULEN che imposta l'orientamento di associazione da utilizzare quando **SQLFetch** o **SQLFetchScroll** viene chiamato sull'istruzione associata. L'associazione per colonna viene selezionata impostando il valore su SQL_BIND_BY_COLUMN. L'associazione per riga viene selezionata impostando il valore sulla lunghezza di una struttura o di un'istanza di un buffer a cui verranno associate le colonne dei risultati.<br /><br /> Se viene specificata una lunghezza, deve includere lo spazio per tutte le colonne associate e qualsiasi riempimento della struttura o del buffer per garantire che quando l'indirizzo di una colonna associata viene incrementato con la lunghezza specificata, il risultato punterà all'inizio della stessa colonna nella riga successiva. Quando si utilizza l'operatore **sizeof** con strutture o unioni in ANSI C, questo comportamento è garantito.<br /><br /> L'associazione per colonna è l'orientamento di associazione predefinito per **SQLFetch** e **SQLFetchScroll**.<br /><br /> Per ulteriori informazioni, consultate [Associazione di colonne da utilizzare con cursori](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md)a blocchi .<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_BIND_TYPE nell'intestazione ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Valore SQLULEN che indica il numero della riga corrente nell'intero set di risultati. Se non è possibile determinare il numero della riga corrente o non è presente alcuna riga corrente, il driver restituisce 0.<br /><br /> Questo attributo può essere recuperato da una chiamata a **SQLGetStmtAttr** ma non impostato da una chiamata a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT utilizzati per ignorare una riga durante un'operazione in blocco utilizzando **SQLSetPos**. Ogni valore è impostato su SQL_ROW_PROCEED (per la riga da includere nell'operazione in blocco) o SQL_ROW_IGNORE (per la riga da escludere dall'operazione in blocco). Le righe non possono essere ignorate utilizzando questa matrice durante le chiamate a **SQLBulkOperations.**<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato della riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva **SQLSetPos** viene chiamato.<br /><br /> Per ulteriori informazioni, vedere [Aggiornamento di righe nel set di righe con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) ed eliminazione di righe nel set di righe con [SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Valore SQLUSMALLINT \* che punta a una matrice di valori SQLUSMALLINT contenente i valori di stato della riga dopo una chiamata a **SQLFetch** o **SQLFetchScroll**. La matrice contiene un numero di elementi quanti sono le righe nel set di righe.<br /><br /> Questo attributo di istruzione può essere impostato su un puntatore null, nel qual caso il driver non restituisce i valori di stato della riga. Questo attributo può essere impostato in qualsiasi momento, ma il nuovo valore non viene utilizzato fino alla successiva chiamata **di SQLBulkOperations**, **SQLFetch** **, SQLFetchScroll**o **SQLSetPos** .<br /><br /> Per ulteriori informazioni, vedere [Numero di righe recuperate e Stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ARRAY_STATUS_PTR nell'intestazione IRD.<br /><br /> Questo attributo viene mappato da un driver ODBC *2.x* alla matrice *rgbRowStatus* in una chiamata a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un valore \* SQLULEN che punta a un buffer in cui restituire il numero di righe recuperate dopo una chiamata a **SQLFetch** o **SQLFetchScroll**; il numero di righe interessate da un'operazione in blocco eseguita da una chiamata a **SQLSetPos** con un argomento *Operation* di SQL_REFRESH; o il numero di righe interessate da un'operazione in blocco eseguita da **SQLBulkOperations**. Questo numero include le righe di errore.<br /><br /> Per ulteriori informazioni, vedere [Numero di righe recuperate e Stato](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> L'impostazione di questo attributo di istruzione imposta il campo SQL_DESC_ROWS_PROCESSED_PTR nell'intestazione IRD.<br /><br /> Se la chiamata a **SQLFetch** o **SQLFetchScroll** che riempie il buffer a cui punta questo attributo non restituisce SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, il contenuto del buffer non è definito.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Valore SQLULEN che specifica se i driver che simulano istruzioni di aggiornamento ed eliminazione posizionate garantiscono che tali istruzioni influiscano su una sola riga.<br /><br /> Per simulare le istruzioni di aggiornamento ed eliminazione posizionate, la maggior parte dei driver crea un'istruzione **UPDATE** o **DELETE** ricercata contenente una clausola **WHERE** che specifica il valore di ogni colonna nella riga corrente. A meno che queste colonne non costituiscano una chiave univoca, tale istruzione può influire su più righe.<br /><br /> Per garantire che tali istruzioni influiscano su una sola riga, il driver determina le colonne in una chiave univoca e aggiunge queste colonne al set di risultati. Se un'applicazione garantisce che le colonne nel set di risultati costituiscono una chiave univoca, il driver non è necessario eseguire questa operazione. Ciò può ridurre i tempi di esecuzione.<br /><br /> SQL_SC_NON_UNIQUE - Il driver non garantisce che le istruzioni simulate di aggiornamento o eliminazione posizionate avranno effetto su una sola riga; è responsabilità dell'applicazione farlo. Se un'istruzione ha effetto su più righe, **SQLExecute**, **SQLExecDirect**o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto di operazioni cursore).<br /><br /> SQL_SC_TRY_UNIQUE - Il driver tenta di garantire che le istruzioni di aggiornamento o eliminazione posizionate simulate influiscano su una sola riga. Il driver esegue sempre tali istruzioni, anche se potrebbero interessare più di una riga, ad esempio quando non è presente alcuna chiave univoca. Se un'istruzione ha effetto su più righe, **SQLExecute**, **SQLExecDirect**o **SQLSetPos** restituisce SQLSTATE 01001 (conflitto di operazioni cursore).<br /><br /> SQL_SC_UNIQUE: il driver garantisce che le istruzioni di aggiornamento o eliminazione posizionate simulate influiscano su una sola riga. Se il driver non è in grado di garantire questo per una determinata istruzione, **SQLExecDirect** o **SQLPrepare** restituisce un errore.<br /><br /> Se l'origine dati fornisce il supporto SQL nativo per le istruzioni di aggiornamento ed eliminazione posizionate e il driver non simula i cursori, SQL_SUCCESS viene restituito quando viene richiesta SQL_SC_UNIQUE per SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO viene restituito se viene richiesto SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Se l'origine dati fornisce il livello di supporto SQL_SC_TRY_UNIQUE e il driver non, SQL_SUCCESS viene restituito per SQL_SC_TRY_UNIQUE e SQL_SUCCESS_WITH_INFO viene restituito per SQL_SC_NON_UNIQUE.<br /><br /> Se il tipo di simulazione del cursore specificato non è supportato dall'origine dati, il driver sostituisce un tipo di simulazione diverso e restituisce SQLSTATE 01S02 (valore opzione modificato). Ad SQL_SC_UNIQUE, il conducente sostituisce, in ordine, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Ad SQL_SC_TRY_UNIQUE, il driver sostituisce SQL_SC_NON_UNIQUE.<br /><br /> Il valore predefinito è SQL_SC_UNIQUE.<br /><br /> Per ulteriori informazioni, vedere [Simulazione di istruzioni di aggiornamento e eliminazione posizionate](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Valore SQLULEN che specifica se un'applicazione utilizzerà segnalibri con un cursore:<br /><br /> SQL_UB_OFF - Disattivato (impostazione predefinita)<br /><br /> SQL_UB_VARIABLE: un'applicazione utilizzerà i segnalibri con un cursore e il driver fornirà segnalibri a lunghezza variabile se supportati. SQL_UB_FIXED è deprecato in ODBC *3.x*. Le applicazioni ODBC *3.x* devono sempre utilizzare segnalibri a lunghezza variabile, anche quando si lavora con driver ODBC *2.x* (che supportavano solo segnalibri a 4 byte a lunghezza fissa). Questo perché un segnalibro a lunghezza fissa è solo un caso speciale di un segnalibro a lunghezza variabile. Quando si utilizza un driver ODBC *2.x,* Gestione Driver esegue il mapping di SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Per utilizzare i segnalibri con un cursore, l'applicazione deve specificare questo attributo con il valore SQL_UB_VARIABLE prima di aprire il cursore.<br /><br /> Per ulteriori informazioni, vedere [Recupero di segnalibri](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] Queste funzioni possono essere chiamate in modo asincrono solo se il descrittore è un descrittore di implementazione, non un descrittore dell'applicazione.  
  
 Vedere [Associazione a colonne](../../../odbc/reference/develop-app/column-wise-binding.md) e [Associazione basata su righe](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funzioni correlate  
  
|Per informazioni su|Vedere|  
|---------------------------|---------|  
|Annullamento dell'elaborazione delle istruzioniCanceling statement processing|[Funzione SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Restituzione dell'impostazione di un attributo di connessioneReturning the setting of a connection attribute|[Funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Restituzione dell'impostazione di un attributo di istruzioneReturning the setting of a statement attribute|[Funzione SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Impostazione di un attributo di connessione|[Pagina relativa alla funzione SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Impostazione di un singolo campo del descrittore|[Funzione SQLSetDescFieldSQLSetDescField Function](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vedere anche  
 [Guida di riferimento all'API ODBCODBC API Reference](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [File di intestazione ODBC](../../../odbc/reference/install/odbc-header-files.md)
